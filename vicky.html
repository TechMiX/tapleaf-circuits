<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <link rel="stylesheet" type="text/css" href="styles.css">
    <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
    <script src="https://unpkg.com/@cmdcode/tapscript@1.4.1"></script>
    <script>
        var $ = document.querySelector.bind( document );
        var $$ = document.querySelectorAll.bind( document );
        var url_params = new URLSearchParams( window.location.search );
        var url_keys = url_params.keys();
        var $_GET = {}
        for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
    </script>
    <script>
        var network = "testnet";
        if ( $_GET[ "network" ] == "regtest" ) network = "regtest";
        var arrprep = ``;
        var arr = [];
        var number_of_preimages_to_expect = null;
        //the following line refers to the "first" number on line 2 of a bristol circuit file
        //e.g. if the second line is 2 64 32 then the following line would be 2 and it means
        //how many numbers are being passed to the function as input
        var number_of_numbers_being_passed_as_input = null;
        //the following line refers to the "second" number on line 2 of a bristol circuit file
        //e.g. if the second line is 2 64 32 then the following line would be 64 and it means
        //how many bits are in the first number passed to the function as input
        var number_of_inputs = null;
        //the following line refers to the "third" number on line 2 of a bristol circuit file
        //e.g. if the second line is 2 64 32 then the following line would be 32 and it means
        //how many bits are in the second number passed to the function as input
        var number_of_inputs_2 = null;
        var number_of_outputs = null;
        var wire_settings = {}
        var wire_hashes = [];
        var operations_array = [];
        var initial_commitment_preimages = [];
        var initial_commitment_hashes = [];
        var subsequent_commitment_preimages = [];
        var subsequent_commitment_hashes = [];
        var copy_of_wire_settings = {}
        var copy_of_operations_array = [];
        var copy_of_initial_commitment_preimages = [];
        var copy_of_initial_commitment_hashes = [];
        var copy_of_subsequent_commitment_preimages = [];
        var copy_of_subsequent_commitment_hashes = [];
        var pauls_key = null;
        var funding_scripts = null;
        var funding_address = null;
        var funding_tpubkey = null;
        var funding_block = null;
        var bit_commitment_address = null;
        var bit_commitment_tpubkey = null;
        var bit_commitment_cblock = null;
        var anti_contradiction_address = null;
        var anti_contradiction_tpubkey = null;
        var anti_contradiction_cblock = null;
        var challenge_address = null;
        var challenge_tpubkey = null;
        var challenge_cblock = null;
        var preimages_from_paul = [];
        var wires = [];
        var challenge_scripts = null;
        var to_challenge_txhex = null;
        var to_challenge_txid = null;
        var to_challenge_vout = null;
        var to_challenge_amt = null;
        var program = null;
        var pauls_promise = null;
        var paul_lied = false;
    </script>
    <script>
        var sha256 = s => {
            if ( typeof s == "string" ) s = new TextEncoder().encode( s );
            return crypto.subtle.digest( 'SHA-256', s ).then( hashBuffer => {
                var hashArray = Array.from( new Uint8Array( hashBuffer ) );
                var hashHex = hashArray
                    .map( bytes => bytes.toString( 16 ).padStart( 2, '0' ) )
                    .join( '' );
                return hashHex;
            });
        }

        function hexToBytes( hex ) {
            return Uint8Array.from( hex.match( /.{1,2}/g ).map( ( byte ) => parseInt( byte, 16 ) ) );
        }

        function bytesToHex( bytes ) {
            return bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" );
        }

        var getRand = size => bytesToHex(crypto.getRandomValues(new Uint8Array(size)));

        var AND = ( a, b ) => Number( a && b );
        var XOR = ( a, b ) => Number( a ^ b );
        var INV = ( a ) => Number( !a );

        function removeDuplicates(arr) {
            var copy = JSON.parse( JSON.stringify( arr ) );
            return copy.filter((item,index) => copy.indexOf(item) === index);
        }

        var compareTapleaves = async ( preimage, challenge_scripts ) => {
            var scripts_this_preimage_is_referenced_in = [];
            var hash = await sha256( hexToBytes( preimage ) );
            challenge_scripts.forEach( ( script, index ) => {
                script.forEach( element => {
                    if ( element == hash ) scripts_this_preimage_is_referenced_in.push( index );
                });
            });
            return scripts_this_preimage_is_referenced_in;
        }

        var discardUnusedPreimages = async () => {
            var i; for ( i=0; i<preimages_from_paul.length; i++ ) {
                var preimage = preimages_from_paul[ i ];
                var tapleaves_it_is_in = await compareTapleaves( preimage, challenge_scripts );
                if ( tapleaves_it_is_in.length ) continue;
                preimages_from_paul.splice( i, 1 );
                i = i - 1;
            }
        }

        var OP_NOT = async ( input_preimage, expected_input_hash, input_value, output_preimage, expected_output_hash, output_value ) => {
            var real_input_hash = await sha256( hexToBytes( input_preimage ) );
            if ( real_input_hash != expected_input_hash ) return `you cannot spend with this tapleaf`;
            var input_bit = input_value;
            input_bit = Number( !input_bit );
            var real_output_hash = await sha256( hexToBytes( output_preimage ) );
            if ( real_output_hash != expected_output_hash ) return `you cannot spend with this tapleaf`;
            var output_bit = output_value;
            if ( input_bit != output_bit ) return `you can spend with these preimages: ${input_preimage} as the input preimage and ${output_preimage} as the output preimage`;
            return `you cannot spend with this tapleaf`;
        }

        var OP_BOOLAND = async ( first_input_preimage, first_expected_input_hash, first_input_value, second_input_preimage, second_expected_input_hash, second_input_value, output_preimage, expected_output_hash, output_value ) => {
            var real_first_input_hash = await sha256( hexToBytes( first_input_preimage ) );
            if ( real_first_input_hash != first_expected_input_hash ) return `you cannot spend with this tapleaf`;
            var real_second_input_hash = await sha256( hexToBytes( second_input_preimage ) );
            if ( real_second_input_hash != second_expected_input_hash ) return `you cannot spend with this tapleaf`;
            var comparison_bit = Number( first_input_value && second_input_value );
            var real_output_hash = await sha256( hexToBytes( output_preimage ) );
            if ( real_output_hash != expected_output_hash ) return `you cannot spend with this tapleaf`;
            var output_bit = output_value;
            if ( comparison_bit != output_bit ) return `you can spend with these preimages: ${first_input_preimage} as the first input preimage, ${second_input_preimage} as the second, and ${output_preimage} as the output preimage`;
            return `you cannot spend with this tapleaf`;
        }

        var OP_XOR = async ( first_input_preimage, first_expected_input_hash, first_input_value, second_input_preimage, second_expected_input_hash, second_input_value, output_preimage, expected_output_hash, output_value ) => {
            var real_first_input_hash = await sha256( hexToBytes( first_input_preimage ) );
            if ( real_first_input_hash != first_expected_input_hash ) return `you cannot spend with this tapleaf`;
            var real_second_input_hash = await sha256( hexToBytes( second_input_preimage ) );
            if ( real_second_input_hash != second_expected_input_hash ) return `you cannot spend with this tapleaf`;
            var comparison_bit = Number( first_input_value ^ second_input_value );
            var real_output_hash = await sha256( hexToBytes( output_preimage ) );
            if ( real_output_hash != expected_output_hash ) return `you cannot spend with this tapleaf`;
            var output_bit = output_value;
            if ( comparison_bit != output_bit ) return `you can spend with these preimages: ${first_input_preimage} as the first input preimage, ${second_input_preimage} as the second, and ${output_preimage} as the output preimage`;
            return `you cannot spend with this tapleaf`;
        }

        var makeBristolArray = () => {
            arr = arrprep.split( `\n`);
            arr.forEach( ( entry, index ) => {
                arr[ index ] = arr[ index ].replace( / +(?= )/g, "" );
                if ( entry.startsWith( " " ) ) arr[ index ] = arr[ index ].substring( 1 );
            });
            if ( !arr[ 0 ] ) arr.splice( 0, 1 );
            if ( !arr[ arr.length - 1 ] ) arr.splice( arr.length - 1, 1 );
            if ( arr[ 3 ] ) alert( "Oops, you entered an invalid bristol circuit! Try again with the whole document, including the first three lines that define the number of gates, number of input bits, and number of output bits." );
            number_of_preimages_to_expect = arr[ 0 ].split( " " ).filter( item => item )[ 1 ];
            number_of_preimages_to_expect = Number( number_of_preimages_to_expect );
            number_of_numbers_being_passed_as_input = arr[ 1 ].split( " " ).filter( item => item )[ 0 ];
            number_of_numbers_being_passed_as_input = Number( number_of_numbers_being_passed_as_input );
            number_of_inputs = arr[ 1 ].split( " " ).filter( item => item )[ 1 ];
            number_of_inputs = Number( number_of_inputs );
            if ( arr[ 1 ].split( " " ).filter( item => item )[ 2 ] ) number_of_inputs_2 = arr[ 1 ].split( " " ).filter( item => item )[ 2 ];
            if ( number_of_inputs_2 ) number_of_inputs_2 = Number( number_of_inputs_2 );
            number_of_outputs = arr[ 2 ].split( " " ).filter( item => item )[ 1 ];
            number_of_outputs = Number( number_of_outputs );
            arr.splice( 0, 4 );
        }

        var copyOfSetOperationsArray = async () => {
            var index; for ( index=0; index<arr.length; index++ ) {
                var gate = arr[ index ].split( " " ).filter( item => item );
                if ( gate[ gate.length - 1 ] == "INV" ) {
                    if ( !copy_of_wire_settings[ gate[ 2 ] ] ) {
                        var input_preimage_0 = getRand( 32 );
                        var input_preimage_1 = getRand( 32 );
                        copy_of_wire_settings[ gate[ 2 ] ] = [input_preimage_0, input_preimage_1];
                    } else {
                        var input_preimage_0 = copy_of_wire_settings[ gate[ 2 ] ][ 0 ];
                        var input_preimage_1 = copy_of_wire_settings[ gate[ 2 ] ][ 1 ];
                    }
                    var output_preimage_0 = getRand( 32 );
                    var output_preimage_1 = getRand( 32 );
                    var input_hash_0 = await sha256( hexToBytes( input_preimage_0 ) );
                    var input_hash_1 = await sha256( hexToBytes( input_preimage_1 ) );
                    if ( !copy_of_initial_commitment_hashes[ gate[ 2 ] ] ) copy_of_initial_commitment_hashes[ gate[ 2 ] ] = [input_hash_0, input_hash_1];
                    var output_hash_0 = await sha256( hexToBytes( output_preimage_0 ) );
                    var output_hash_1 = await sha256( hexToBytes( output_preimage_1 ) );
                    copy_of_wire_settings[ gate[ 3 ] ] = [output_preimage_0, output_preimage_1];
                    copy_of_operations_array.push( ["INV", ["input_preimages", input_preimage_0, input_preimage_1], ["output_preimages", output_preimage_0, output_preimage_1], ["input_hashes", input_hash_0, input_hash_1], ["output_hashes", output_hash_0, output_hash_1], `var w_${gate[ 3 ]} = INV( wires[ ${gate[ 2 ]} ] )`] );
                }
                if ( gate[ gate.length - 1 ] == "AND" ) {
                    if ( !copy_of_wire_settings[ gate[ 2 ] ] ) {
                        var first_input_preimage_0 = getRand( 32 );
                        var first_input_preimage_1 = getRand( 32 );
                        copy_of_wire_settings[ gate[ 2 ] ] = [first_input_preimage_0, first_input_preimage_1];
                    } else {
                        var first_input_preimage_0 = copy_of_wire_settings[ gate[ 2 ] ][ 0 ];
                        var first_input_preimage_1 = copy_of_wire_settings[ gate[ 2 ] ][ 1 ];
                    }
                    if ( !copy_of_wire_settings[ gate[ 3 ] ] ) {
                        var second_input_preimage_0 = getRand( 32 );
                        var second_input_preimage_1 = getRand( 32 );
                        copy_of_wire_settings[ gate[ 3 ] ] = [second_input_preimage_0, second_input_preimage_1];
                    } else {
                        var second_input_preimage_0 = copy_of_wire_settings[ gate[ 3 ] ][ 0 ];
                        var second_input_preimage_1 = copy_of_wire_settings[ gate[ 3 ] ][ 1 ];
                    }
                    var output_preimage_0 = getRand( 32 );
                    var output_preimage_1 = getRand( 32 );
                    var first_input_hash_0 = await sha256( hexToBytes( first_input_preimage_0 ) );
                    var first_input_hash_1 = await sha256( hexToBytes( first_input_preimage_1 ) );
                    if ( !copy_of_initial_commitment_hashes[ gate[ 2 ] ] ) copy_of_initial_commitment_hashes[ gate[ 2 ] ] = [first_input_hash_0, first_input_hash_1];
                    var second_input_hash_0 = await sha256( hexToBytes( second_input_preimage_0 ) );
                    var second_input_hash_1 = await sha256( hexToBytes( second_input_preimage_1 ) );
                    if ( !copy_of_initial_commitment_hashes[ gate[ 3 ] ] ) copy_of_initial_commitment_hashes[ gate[ 3 ] ] = [second_input_hash_0, second_input_hash_1];
                    var output_hash_0 = await sha256( hexToBytes( output_preimage_0 ) );
                    var output_hash_1 = await sha256( hexToBytes( output_preimage_1 ) );
                    copy_of_wire_settings[ gate[ 4 ] ] = [output_preimage_0, output_preimage_1];
                    copy_of_operations_array.push( ["AND", ["first_input_preimages", first_input_preimage_0, first_input_preimage_1], ["second_input_preimages", second_input_preimage_0, second_input_preimage_1], ["output_preimages", output_preimage_0, output_preimage_1], ["first_input_hashes", first_input_hash_0, first_input_hash_1], ["second_input_hashes", second_input_hash_0, second_input_hash_1], ["output_hashes", output_hash_0, output_hash_1], `var w_${gate[ 4 ]} = AND( wires[ ${gate[ 2 ]} ], wires[ ${gate[ 3 ]} ] )`] );
                }
                if ( gate[ gate.length - 1 ] == "XOR" ) {
                    if ( !copy_of_wire_settings[ gate[ 2 ] ] ) {
                        var first_input_preimage_0 = getRand( 32 );
                        var first_input_preimage_1 = getRand( 32 );
                        copy_of_wire_settings[ gate[ 2 ] ] = [first_input_preimage_0, first_input_preimage_1];
                    } else {
                        var first_input_preimage_0 = copy_of_wire_settings[ gate[ 2 ] ][ 0 ];
                        var first_input_preimage_1 = copy_of_wire_settings[ gate[ 2 ] ][ 1 ];
                    }
                    if ( !copy_of_wire_settings[ gate[ 3 ] ] ) {
                        var second_input_preimage_0 = getRand( 32 );
                        var second_input_preimage_1 = getRand( 32 );
                        copy_of_wire_settings[ gate[ 3 ] ] = [second_input_preimage_0, second_input_preimage_1];
                    } else {
                        var second_input_preimage_0 = copy_of_wire_settings[ gate[ 3 ] ][ 0 ];
                        var second_input_preimage_1 = copy_of_wire_settings[ gate[ 3 ] ][ 1 ];
                    }
                    var output_preimage_0 = getRand( 32 );
                    var output_preimage_1 = getRand( 32 );
                    var first_input_hash_0 = await sha256( hexToBytes( first_input_preimage_0 ) );
                    var first_input_hash_1 = await sha256( hexToBytes( first_input_preimage_1 ) );
                    if ( !copy_of_initial_commitment_hashes[ gate[ 2 ] ] ) copy_of_initial_commitment_hashes[ gate[ 2 ] ] = [first_input_hash_0, first_input_hash_1];
                    var second_input_hash_0 = await sha256( hexToBytes( second_input_preimage_0 ) );
                    var second_input_hash_1 = await sha256( hexToBytes( second_input_preimage_1 ) );
                    if ( !copy_of_initial_commitment_hashes[ gate[ 3 ] ] ) copy_of_initial_commitment_hashes[ gate[ 3 ] ] = [second_input_hash_0, second_input_hash_1];
                    var output_hash_0 = await sha256( hexToBytes( output_preimage_0 ) );
                    var output_hash_1 = await sha256( hexToBytes( output_preimage_1 ) );
                    copy_of_wire_settings[ gate[ 4 ] ] = [output_preimage_0, output_preimage_1];
                    copy_of_operations_array.push( ["XOR", ["first_input_preimages", first_input_preimage_0, first_input_preimage_1], ["second_input_preimages", second_input_preimage_0, second_input_preimage_1], ["output_preimages", output_preimage_0, output_preimage_1], ["first_input_hashes", first_input_hash_0, first_input_hash_1], ["second_input_hashes", second_input_hash_0, second_input_hash_1], ["output_hashes", output_hash_0, output_hash_1], `var w_${gate[ 4 ]} = XOR( wires[ ${gate[ 2 ]} ], wires[ ${gate[ 3 ]} ] )`] );
                }
            }
        }

        setOperationsArray = async () => {
            var index; for ( index=0; index<arr.length; index++ ) {
                var gate = arr[ index ].split( " " ).filter( item => item );
                if ( gate[ gate.length - 1 ] == "INV" ) {
                    if ( !wire_settings[ gate[ 2 ] ] ) {
                        var input_preimage_0 = getRand( 32 );
                        var input_preimage_1 = getRand( 32 );
                        wire_settings[ gate[ 2 ] ] = [input_preimage_0, input_preimage_1];
                    } else {
                        var input_preimage_0 = wire_settings[ gate[ 2 ] ][ 0 ];
                        var input_preimage_1 = wire_settings[ gate[ 2 ] ][ 1 ];
                    }
                    var output_preimage_0 = copy_of_wire_settings[ gate[ 3 ] ][ 0 ];
                    var output_preimage_1 = copy_of_wire_settings[ gate[ 3 ] ][ 1 ];
                    var copy_of_input_hash_0 = await sha256( hexToBytes( copy_of_wire_settings[ gate[ 2 ] ][ 0 ] ) );
                    var copy_of_input_hash_1 = await sha256( hexToBytes( copy_of_wire_settings[ gate[ 2 ] ][ 1 ] ) );
                    var hash_info = findHashesInCopy( copy_of_input_hash_0, copy_of_input_hash_1 );
                    var index_of_input_hashes = hash_info[ 0 ];
                    var array_to_use = hash_info[ 1 ] == "sub" ? subsequent_commitment_hashes : initial_commitment_hashes;
                    var input_hash_0 = array_to_use[ index_of_input_hashes ][ 0 ];
                    var input_hash_1 = array_to_use[ index_of_input_hashes ][ 1 ];
                    if ( !wire_hashes[ gate[ 2 ] ] ) wire_hashes[ gate[ 2 ] ] = [input_hash_0, input_hash_1];
                    var hash_info_test = JSON.parse( JSON.stringify( hash_info ) );
                    //Vicky should be able to view the output hashes in her own copies of operations_array and
                    //subsequent_commitment_hashes that she creates. Then she can grab the "right" hashes from
                    //the corresponding indices of the "real" subsequent_commitment_hashes she gets from Paul
                    var copy_of_output_hash_0 = await sha256( hexToBytes( output_preimage_0 ) );
                    var copy_of_output_hash_1 = await sha256( hexToBytes( output_preimage_1 ) );
                    var hash_info = findHashesInCopy( copy_of_output_hash_0, copy_of_output_hash_1 );
                    var index_of_output_hashes = hash_info[ 0 ];
                    var array_to_use = hash_info[ 1 ] == "sub" ? subsequent_commitment_hashes : initial_commitment_hashes;
                    var real_output_hash_0 = array_to_use[ index_of_output_hashes ][ 0 ];
                    var real_output_hash_1 = array_to_use[ index_of_output_hashes ][ 1 ];
                    wire_settings[ gate[ 3 ] ] = [output_preimage_0, output_preimage_1];
                    wire_hashes[ gate[ 3 ] ] = [real_output_hash_0, real_output_hash_1];
                    operations_array.push( ["INV", ["input_preimages", input_preimage_0, input_preimage_1], ["output_preimages", output_preimage_0, output_preimage_1], ["input_hashes", input_hash_0, input_hash_1], ["output_hashes", real_output_hash_0, real_output_hash_1], `var w_${gate[ 3 ]} = INV( wires[ ${gate[ 2 ]} ] )`] );
                }
                if ( gate[ gate.length - 1 ] == "AND" ) {
                    if ( !wire_settings[ gate[ 2 ] ] ) {
                        var first_input_preimage_0 = getRand( 32 );
                        var first_input_preimage_1 = getRand( 32 );
                        wire_settings[ gate[ 2 ] ] = [first_input_preimage_0, first_input_preimage_1];
                    } else {
                        var first_input_preimage_0 = wire_settings[ gate[ 2 ] ][ 0 ];
                        var first_input_preimage_1 = wire_settings[ gate[ 2 ] ][ 1 ];
                    }
                    if ( !wire_settings[ gate[ 3 ] ] ) {
                        var second_input_preimage_0 = getRand( 32 );
                        var second_input_preimage_1 = getRand( 32 );
                        wire_settings[ gate[ 3 ] ] = [second_input_preimage_0, second_input_preimage_1];
                    } else {
                        var second_input_preimage_0 = wire_settings[ gate[ 3 ] ][ 0 ];
                        var second_input_preimage_1 = wire_settings[ gate[ 3 ] ][ 1 ];
                    }
                    var output_preimage_0 = copy_of_wire_settings[ gate[ 4 ] ][ 0 ];
                    var output_preimage_1 = copy_of_wire_settings[ gate[ 4 ] ][ 1 ];
                    var copy_of_first_input_hash_0 = await sha256( hexToBytes( copy_of_wire_settings[ gate[ 2 ] ][ 0 ] ) );
                    var copy_of_first_input_hash_1 = await sha256( hexToBytes( copy_of_wire_settings[ gate[ 2 ] ][ 1 ] ) );
                    var hash_info = findHashesInCopy( copy_of_first_input_hash_0, copy_of_first_input_hash_1 );
                    var index_of_first_input_hashes = hash_info[ 0 ];
                    var array_to_use = hash_info[ 1 ] == "sub" ? subsequent_commitment_hashes : initial_commitment_hashes;
                    var first_input_hash_0 = array_to_use[ index_of_first_input_hashes ][ 0 ];
                    var first_input_hash_1 = array_to_use[ index_of_first_input_hashes ][ 1 ];
                    if ( !wire_hashes[ gate[ 2 ] ] ) wire_hashes[ gate[ 2 ] ] = [first_input_hash_0, first_input_hash_1];
                    var copy_of_second_input_hash_0 = await sha256( hexToBytes( copy_of_wire_settings[ gate[ 3 ] ][ 0 ] ) );
                    var copy_of_second_input_hash_1 = await sha256( hexToBytes( copy_of_wire_settings[ gate[ 3 ] ][ 1 ] ) );
                    var hash_info = findHashesInCopy( copy_of_second_input_hash_0, copy_of_second_input_hash_1 );
                    var index_of_second_input_hashes = hash_info[ 0 ];
                    var array_to_use = hash_info[ 1 ] == "sub" ? subsequent_commitment_hashes : initial_commitment_hashes;
                    var second_input_hash_0 = array_to_use[ index_of_second_input_hashes ][ 0 ];
                    var second_input_hash_1 = array_to_use[ index_of_second_input_hashes ][ 1 ];
                    if ( !wire_hashes[ gate[ 3 ] ] ) wire_hashes[ gate[ 3 ] ] = [second_input_hash_0, second_input_hash_1];
                    var copy_of_output_hash_0 = await sha256( hexToBytes( output_preimage_0 ) );
                    var copy_of_output_hash_1 = await sha256( hexToBytes( output_preimage_1 ) );
                    var hash_info = findHashesInCopy( copy_of_output_hash_0, copy_of_output_hash_1 );
                    var index_of_output_hashes = hash_info[ 0 ];
                    var array_to_use = hash_info[ 1 ] == "sub" ? subsequent_commitment_hashes : initial_commitment_hashes;
                    var real_output_hash_0 = array_to_use[ index_of_output_hashes ][ 0 ];
                    var real_output_hash_1 = array_to_use[ index_of_output_hashes ][ 1 ];
                    wire_settings[ gate[ 4 ] ] = [output_preimage_0, output_preimage_1];
                    wire_hashes[ gate[ 4 ] ] = [real_output_hash_0, real_output_hash_1];
                    operations_array.push( ["AND", ["first_input_preimages", first_input_preimage_0, first_input_preimage_1], ["second_input_preimages", second_input_preimage_0, second_input_preimage_1], ["output_preimages", output_preimage_0, output_preimage_1], ["first_input_hashes", first_input_hash_0, first_input_hash_1], ["second_input_hashes", second_input_hash_0, second_input_hash_1], ["output_hashes", real_output_hash_0, real_output_hash_1], `var w_${gate[ 4 ]} = AND( wires[ ${gate[ 2 ]} ], wires[ ${gate[ 3 ]} ] )`] );
                }
                if ( gate[ gate.length - 1 ] == "XOR" ) {
                    if ( !wire_settings[ gate[ 2 ] ] ) {
                        var first_input_preimage_0 = getRand( 32 );
                        var first_input_preimage_1 = getRand( 32 );
                        wire_settings[ gate[ 2 ] ] = [first_input_preimage_0, first_input_preimage_1];
                    } else {
                        var first_input_preimage_0 = wire_settings[ gate[ 2 ] ][ 0 ];
                        var first_input_preimage_1 = wire_settings[ gate[ 2 ] ][ 1 ];
                    }
                    if ( !wire_settings[ gate[ 3 ] ] ) {
                        var second_input_preimage_0 = getRand( 32 );
                        var second_input_preimage_1 = getRand( 32 );
                        wire_settings[ gate[ 3 ] ] = [second_input_preimage_0, second_input_preimage_1];
                    } else {
                        var second_input_preimage_0 = wire_settings[ gate[ 3 ] ][ 0 ];
                        var second_input_preimage_1 = wire_settings[ gate[ 3 ] ][ 1 ];
                    }
                    var output_preimage_0 = copy_of_wire_settings[ gate[ 4 ] ][ 0 ];
                    var output_preimage_1 = copy_of_wire_settings[ gate[ 4 ] ][ 1 ];
                    var copy_of_first_input_hash_0 = await sha256( hexToBytes( copy_of_wire_settings[ gate[ 2 ] ][ 0 ] ) );
                    var copy_of_first_input_hash_1 = await sha256( hexToBytes( copy_of_wire_settings[ gate[ 2 ] ][ 1 ] ) );
                    var hash_info = findHashesInCopy( copy_of_first_input_hash_0, copy_of_first_input_hash_1 );
                    var index_of_first_input_hashes = hash_info[ 0 ];
                    var array_to_use = hash_info[ 1 ] == "sub" ? subsequent_commitment_hashes : initial_commitment_hashes;
                    var first_input_hash_0 = array_to_use[ index_of_first_input_hashes ][ 0 ];
                    var first_input_hash_1 = array_to_use[ index_of_first_input_hashes ][ 1 ];
                    if ( !wire_hashes[ gate[ 2 ] ] ) wire_hashes[ gate[ 2 ] ] = [first_input_hash_0, first_input_hash_1];
                    var copy_of_second_input_hash_0 = await sha256( hexToBytes( copy_of_wire_settings[ gate[ 3 ] ][ 0 ] ) );
                    var copy_of_second_input_hash_1 = await sha256( hexToBytes( copy_of_wire_settings[ gate[ 3 ] ][ 1 ] ) );
                    var hash_info = findHashesInCopy( copy_of_second_input_hash_0, copy_of_second_input_hash_1 );
                    var index_of_second_input_hashes = hash_info[ 0 ];
                    var array_to_use = hash_info[ 1 ] == "sub" ? subsequent_commitment_hashes : initial_commitment_hashes;
                    var second_input_hash_0 = array_to_use[ index_of_second_input_hashes ][ 0 ];
                    var second_input_hash_1 = array_to_use[ index_of_second_input_hashes ][ 1 ];
                    if ( !wire_hashes[ gate[ 3 ] ] ) wire_hashes[ gate[ 3 ] ] = [second_input_hash_0, second_input_hash_1];
                    var copy_of_output_hash_0 = await sha256( hexToBytes( output_preimage_0 ) );
                    var copy_of_output_hash_1 = await sha256( hexToBytes( output_preimage_1 ) );
                    var hash_info = findHashesInCopy( copy_of_output_hash_0, copy_of_output_hash_1 );
                    var index_of_output_hashes = hash_info[ 0 ];
                    var array_to_use = hash_info[ 1 ] == "sub" ? subsequent_commitment_hashes : initial_commitment_hashes;
                    var real_output_hash_0 = array_to_use[ index_of_output_hashes ][ 0 ];
                    var real_output_hash_1 = array_to_use[ index_of_output_hashes ][ 1 ];
                    wire_settings[ gate[ 4 ] ] = [output_preimage_0, output_preimage_1];
                    wire_hashes[ gate[ 4 ] ] = [real_output_hash_0, real_output_hash_1];
                    operations_array.push( ["XOR", ["first_input_preimages", first_input_preimage_0, first_input_preimage_1], ["second_input_preimages", second_input_preimage_0, second_input_preimage_1], ["output_preimages", output_preimage_0, output_preimage_1], ["first_input_hashes", first_input_hash_0, first_input_hash_1], ["second_input_hashes", second_input_hash_0, second_input_hash_1], ["output_hashes", real_output_hash_0, real_output_hash_1], `var w_${gate[ 4 ]} = XOR( wires[ ${gate[ 2 ]} ], wires[ ${gate[ 3 ]} ] )`] );
                }
            }
        }

        var findHashesInCopy = ( hash1, hash2 ) => {
            var i; for ( i=0; i<copy_of_subsequent_commitment_hashes.length; i++ ) {
                if ( copy_of_subsequent_commitment_hashes[ i ].includes( hash1 ) && copy_of_subsequent_commitment_hashes[ i ].includes( hash2 ) ) return [i, "sub"];
            }
            var i; for ( i=0; i<copy_of_initial_commitment_hashes.length; i++ ) {
                if ( copy_of_initial_commitment_hashes[ i ] && copy_of_initial_commitment_hashes[ i ].includes( hash1 ) && copy_of_initial_commitment_hashes[ i ].includes( hash2 ) ) return [i, "init"];
            }
        }

        var generateBitCommitments = async () => {
            var i; for ( i=0; i<64; i++ ) {
                initial_commitment_preimages.push( wire_settings[ String( i ) ] );
                var preimage_0 = wire_settings[ String( i ) ][ 0 ];
                var preimage_1 = wire_settings[ String( i ) ][ 1 ];
                var hash_0 = await sha256( hexToBytes( preimage_0 ) );
                var hash_1 = await sha256( hexToBytes( preimage_1 ) );
                initial_commitment_hashes.push( [ hash_0, hash_1 ] );
            }
        }

        var generateBitCommitmentAddress = pubkey => {
            var leaf1 = [
                "OP_10",
                "OP_CHECKSEQUENCEVERIFY",
                "OP_DROP",
                pubkey,
                "OP_CHECKSIG"
            ];

            var leaf2 = [
                "OP_0",
                pauls_key,
                "OP_CHECKSIGADD",
                pubkey,
                "OP_CHECKSIGADD",
                "OP_2",
                "OP_EQUAL"
            ];

            var bit_commitment_template = `
                OP_SHA256
                INSERT_16_BYTE_HERE
                OP_EQUAL
                OP_SWAP
                OP_SHA256
                INSERT_17_BYTE_HERE
                OP_EQUAL
                OP_BOOLOR
                OP_VERIFY
            `;

            var bit_commitment_script = ``;

            initial_commitment_hashes.forEach( hash_pair => {
                bit_commitment_script += bit_commitment_template.replace( "INSERT_16_BYTE_HERE", hash_pair[ 0 ] ).replace( "INSERT_17_BYTE_HERE", hash_pair[ 1 ] );
            });

            subsequent_commitment_hashes.forEach( hash_pair => {
                bit_commitment_script += bit_commitment_template.replace( "INSERT_16_BYTE_HERE", hash_pair[ 0 ] ).replace( "INSERT_17_BYTE_HERE", hash_pair[ 1 ] );
            });

            bit_commitment_script += `
               ${pauls_key}
               OP_CHECKSIG
            `;

            // bit_commitment_script += `
                // OP_1
            // `;

            var bit_commitment_script_array = bit_commitment_script.replaceAll( "\n\n", "\n" ).replaceAll( " ", "" ).split( "\n" );
            bit_commitment_script_array.splice( 0, 1 );
            bit_commitment_script_array.splice( bit_commitment_script_array.length - 1, 1 );

            var leaf3 = bit_commitment_script_array;

            var scripts = [leaf1, leaf2, leaf3];
            var tree = scripts.map( s => tapscript.Tap.encodeScript( s ) );
            var selected_script = scripts[ 2 ];
            bit_commitment_script = selected_script;
            var target = tapscript.Tap.encodeScript( selected_script );
            var pubkey = "ab".repeat( 32 );
            var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
            bit_commitment_tpubkey = tpubkey;
            bit_commitment_cblock = cblock;
            var bit_commitment_address = tapscript.Address.p2tr.fromPubKey( tpubkey, network );
            return bit_commitment_address;
        }

        var generateAntiContradictionAddress = pubkey => {
            var anti_contradiction_template = `
                OP_SHA256
                INSERT_16_BYTE_HERE
                OP_EQUALVERIFY
                OP_SHA256
                INSERT_17_BYTE_HERE
                OP_EQUALVERIFY
                ${pubkey}
                OP_CHECKSIG
            `;

            var anti_contradiction_scripts = [];

            initial_commitment_hashes.forEach( hash_pair => {
                var filled_in = anti_contradiction_template.replace( "INSERT_16_BYTE_HERE", hash_pair[ 0 ] ).replace( "INSERT_17_BYTE_HERE", hash_pair[ 1 ] );
                var leaf = filled_in.replaceAll( "\n\n", "\n" ).replaceAll( " ", "" ).split( "\n" );
                leaf.splice( 0, 1 );
                leaf.splice( leaf.length - 1, 1 );
                anti_contradiction_scripts.push( leaf );
            });

            subsequent_commitment_hashes.forEach( hash_pair => {
                var filled_in = anti_contradiction_template.replace( "INSERT_16_BYTE_HERE", hash_pair[ 0 ] ).replace( "INSERT_17_BYTE_HERE", hash_pair[ 1 ] );
                var leaf = filled_in.replaceAll( "\n\n", "\n" ).replaceAll( " ", "" ).split( "\n" );
                leaf.splice( 0, 1 );
                leaf.splice( leaf.length - 1, 1 );
                anti_contradiction_scripts.push( leaf );
            });

            var last_leaf = [
                "OP_10",
                "OP_CHECKSEQUENCEVERIFY",
                "OP_DROP",
                pauls_key,
                "OP_CHECKSIG"
            ];

            anti_contradiction_scripts.push( last_leaf );

            var tree = anti_contradiction_scripts.map( s => tapscript.Tap.encodeScript( s ) );
            var selected_script = anti_contradiction_scripts[ 0 ];
            anti_contradiction_script = selected_script;
            var target = tapscript.Tap.encodeScript( selected_script );
            var pubkey = "ab".repeat( 32 );
            var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
            anti_contradiction_tpubkey = tpubkey;
            anti_contradiction_cblock = cblock;
            var anti_contradiction_address = tapscript.Address.p2tr.fromPubKey( tpubkey, network );
            return anti_contradiction_address;
        }

        var generateChallengeAddress = pubkey => {
            var templates = {}
            templates[ "OP_NOT_00" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NOT
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_NOT_01" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NOT
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_NOT_10" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NOT
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_NOT_11" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NOT
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_BOOLAND_000" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_BOOLAND
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_BOOLAND_001" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_BOOLAND
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_BOOLAND_010" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_BOOLAND
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_BOOLAND_011" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_BOOLAND
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_BOOLAND_100" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_BOOLAND
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_BOOLAND_101" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_BOOLAND
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_BOOLAND_110" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_BOOLAND
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_BOOLAND_111" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_BOOLAND
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_XOR_000" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_XOR_001" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_XOR_010" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_XOR_011" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_XOR_100" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_XOR_101" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_XOR_110" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_0
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;
            templates[ "OP_XOR_111" ] = `
                OP_TOALTSTACK
                OP_SHA256
                INSERT_FIRST_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_SWAP
                OP_SHA256
                INSERT_SECOND_INPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_FROMALTSTACK
                OP_SHA256
                INSERT_OUTPUT_HERE
                OP_EQUALVERIFY
                OP_1
                OP_NUMNOTEQUAL
                OP_VERIFY
                ${pubkey}
                OP_CHECKSIG
            `;

            challenge_scripts = [];

            var i; for ( i=0; i<operations_array.length; i++ ) {
                if ( operations_array[ i ][ 0 ] == "INV" ) {
                    var input_hash_pair = [ operations_array[ i ][ 3 ][ 1 ], operations_array[ i ][ 3 ][ 2 ] ];
                    var output_hash_pair = [ operations_array[ i ][ 4 ][ 1 ], operations_array[ i ][ 4 ][ 2 ] ];
                    var filled_in_templates = [];
                    filled_in_templates.push(
                        templates[ "OP_NOT_00" ].replace( "INSERT_INPUT_HERE", input_hash_pair[ 0 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 0 ] ),
                        templates[ "OP_NOT_01" ].replace( "INSERT_INPUT_HERE", input_hash_pair[ 0 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 1 ] ),
                        templates[ "OP_NOT_10" ].replace( "INSERT_INPUT_HERE", input_hash_pair[ 1 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 0 ] ),
                        templates[ "OP_NOT_11" ].replace( "INSERT_INPUT_HERE", input_hash_pair[ 1 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 1 ] )
                    );
                    filled_in_templates.forEach( template => {
                        var leaf = template.replaceAll( "\n\n", "\n" ).replaceAll( " ", "" ).split( "\n" );
                        leaf.splice( 0, 1 );
                        leaf.splice( leaf.length - 1, 1 );
                        challenge_scripts.push( leaf );
                    });
                }
                if ( operations_array[ i ][ 0 ] == "AND" ) {
                    var first_hash_pair = [ operations_array[ i ][ 4 ][ 1 ], operations_array[ i ][ 4 ][ 2 ] ];
                    var second_hash_pair = [ operations_array[ i ][ 5 ][ 1 ], operations_array[ i ][ 5 ][ 2 ] ];
                    var output_hash_pair = [ operations_array[ i ][ 6 ][ 1 ], operations_array[ i ][ 6 ][ 2 ] ];
                    var filled_in_templates = [];
                    filled_in_templates.push(
                        templates[ "OP_BOOLAND_000" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 0 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 0 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 0 ] ),
                        templates[ "OP_BOOLAND_001" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 0 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 0 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 1 ] ),
                        templates[ "OP_BOOLAND_010" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 0 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 1 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 0 ] ),
                        templates[ "OP_BOOLAND_011" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 0 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 1 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 1 ] ),
                        templates[ "OP_BOOLAND_100" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 1 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 0 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 0 ] ),
                        templates[ "OP_BOOLAND_101" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 1 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 0 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 1 ] ),
                        templates[ "OP_BOOLAND_110" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 1 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 1 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 0 ] ),
                        templates[ "OP_BOOLAND_111" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 1 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 1 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 1 ] ),
                    );
                    filled_in_templates.forEach( template => {
                        var leaf = template.replaceAll( "\n\n", "\n" ).replaceAll( " ", "" ).split( "\n" );
                        leaf.splice( 0, 1 );
                        leaf.splice( leaf.length - 1, 1 );
                        challenge_scripts.push( leaf );
                    });
                }
                if ( operations_array[ i ][ 0 ] == "XOR" ) {
                    var first_hash_pair = [ operations_array[ i ][ 4 ][ 1 ], operations_array[ i ][ 4 ][ 2 ] ];
                    var second_hash_pair = [ operations_array[ i ][ 5 ][ 1 ], operations_array[ i ][ 5 ][ 2 ] ];
                    var output_hash_pair = [ operations_array[ i ][ 6 ][ 1 ], operations_array[ i ][ 6 ][ 2 ] ];
                    var filled_in_templates = [];
                    filled_in_templates.push(
                        templates[ "OP_XOR_000" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 0 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 0 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 0 ] ),
                        templates[ "OP_XOR_001" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 0 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 0 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 1 ] ),
                        templates[ "OP_XOR_010" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 0 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 1 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 0 ] ),
                        templates[ "OP_XOR_011" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 0 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 1 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 1 ] ),
                        templates[ "OP_XOR_100" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 1 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 0 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 0 ] ),
                        templates[ "OP_XOR_101" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 1 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 0 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 1 ] ),
                        templates[ "OP_XOR_110" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 1 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 1 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 0 ] ),
                        templates[ "OP_XOR_111" ].replace( "INSERT_FIRST_INPUT_HERE", first_hash_pair[ 1 ] ).replace( "INSERT_SECOND_INPUT_HERE", second_hash_pair[ 1 ] ).replace( "INSERT_OUTPUT_HERE", output_hash_pair[ 1 ] ),
                    );
                    filled_in_templates.forEach( template => {
                        var leaf = template.replaceAll( "\n\n", "\n" ).replaceAll( " ", "" ).split( "\n" );
                        leaf.splice( 0, 1 );
                        leaf.splice( leaf.length - 1, 1 );
                        challenge_scripts.push( leaf );
                    });
                }
            }

            var last_leaf = [
                "OP_10",
                "OP_CHECKSEQUENCEVERIFY",
                "OP_DROP",
                pauls_key,
                "OP_CHECKSIG"
            ];

            challenge_scripts.push( last_leaf );

            var tree = challenge_scripts.map( s => tapscript.Tap.encodeScript( s ) );
            var selected_script = challenge_scripts[ challenge_scripts.length - 1 ];
            challenge_script = selected_script;
            var target = tapscript.Tap.encodeScript( selected_script );
            var pubkey = "ab".repeat( 32 );
            var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
            challenge_tpubkey = tpubkey;
            challenge_cblock = cblock;
            var challenge_address = tapscript.Address.p2tr.fromPubKey( tpubkey, network );
            return challenge_address;
        }

        var generateFundingAddress = pubkey => {
            funding_scripts = [];

            var first_leaf = [
                "OP_10",
                "OP_CHECKSEQUENCEVERIFY",
                "OP_DROP",
                pauls_key,
                "OP_CHECKSIG"
            ];

            funding_scripts.push( first_leaf );

            var second_leaf = [
                "OP_0",
                pauls_key,
                "OP_CHECKSIGADD",
                pubkey,
                "OP_CHECKSIGADD",
                "OP_2",
                "OP_EQUAL"
            ];

            funding_scripts.push( second_leaf );

            var tree = funding_scripts.map( s => tapscript.Tap.encodeScript( s ) );
            var selected_script = funding_scripts[ 0 ];
            funding_script = selected_script;
            var target = tapscript.Tap.encodeScript( selected_script );
            var pubkey = "ab".repeat( 32 );
            var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
            funding_tpubkey = tpubkey;
            funding_cblock = cblock;
            var funding_address = tapscript.Address.p2tr.fromPubKey( tpubkey, network );
            return funding_address;
        }
        var logInputs = async () => {
            //var input_prep = ``;
            var j; for ( j=0; j<initial_commitment_hashes.length; j++ ) {
                var index = j;
                var input = initial_commitment_hashes[ index ];
                //input_prep += `Input #${index + 1} is `;
                var i; for ( i=0; i<preimages_from_paul.length; i++ ) {
                    var preimage = preimages_from_paul[ i ];
                    var hash = await sha256( hexToBytes( preimage ) );
                    if ( hash == input[ 0 ] ) {
                        wires[ index ] = 0;
                        //input_prep += `0 because the preimage to ${input[ 0 ]} was revealed (its preimage is ${preimage})\n\n`;
                        break;
                    }
                    if ( hash == input[ 1 ] ) {
                        wires[ index ] = 1;
                        //input_prep += `1 because the preimage to ${input[ 1 ]} was revealed (its preimage is ${preimage})\n\n`;
                        break;
                    }
                }
            }
            //console.log( input_prep );
        }
        var waitSomeSeconds = num => {
            var num = num.toString() + "000";
            num = Number( num );
            return new Promise( resolve => setTimeout( resolve, num ) );
        }
        var reverseString = s => s.match(/.{1}/g).reverse().join('');
    </script>
</head>
<body>
    <div id="uploader_div">
        <h1>Upload Paul's promise file</h1>
        <p>Here is your public key: <span class="vicky_key"></span></p>
        <p>Paul will shortly send you a "promise file." Upload it here.</p>
        <form method="post" class="box">
            <div class="box__input">
                <svg class="box__icon" xmlns="http://www.w3.org/2000/svg" width="50" height="43" viewBox="0 0 50 43" onclick='document.getElementById( "file_label" ).click();'><path d="M48.4 26.5c-.9 0-1.7.7-1.7 1.7v11.6h-43.3v-11.6c0-.9-.7-1.7-1.7-1.7s-1.7.7-1.7 1.7v13.2c0 .9.7 1.7 1.7 1.7h46.7c.9 0 1.7-.7 1.7-1.7v-13.2c0-1-.7-1.7-1.7-1.7zm-24.5 6.1c.3.3.8.5 1.2.5.4 0 .9-.2 1.2-.5l10-11.6c.7-.7.7-1.7 0-2.4s-1.7-.7-2.4 0l-7.1 8.3v-25.3c0-.9-.7-1.7-1.7-1.7s-1.7.7-1.7 1.7v25.3l-7.1-8.3c-.7-.7-1.7-.7-2.4 0s-.7 1.7 0 2.4l10 11.6z"/></svg>
                <input type="file" name="files[]" id="file" class="box__file" data-multiple-caption="{count} files selected" multiple style="display: none;" onchange="if ( this.files[ 0 ].size < 100000 ) {getFile(this);} else {alert( 'File too large, make sure it is less than 100 kilobytes' ); this.value = null;}" />
                <label for="file" id="file_label"><strong>Choose a file</strong><span class="box__dragndrop"> or drag it here</span></label>
                <button type="submit" class="box__button">Upload</button>
            </div>        
            <div class="box__uploading">Uploading&hellip;</div>
            <div class="box__success">Done!</div>
            <div class="box__error">Error! <span></span>. <a class="box__restart" role="button">Try again!</a></div>
        </form>
    </div>
    <div class="address_verification_div hidden">
        <p>
            Time to validate that you and Paul generated the same bitcoin addresses. Do all of these match what Paul got? (Note: don't send any money to them yet)
        </p>
        <div class="address_validation">loading...</div>
        <p><button class="address_verification_done">Yes, they match</button> <button class="address_verification_reset">No, they don't match</button></p>
    </div>
    <div class="wait_for_sigs_div hidden">
        <p>
            Enter the bitcoin address where you want Paul's money to go if he breaks his promise:
        </p>
        <p><input class="vickys_bitcoin_address"></p>
        <p>Hint: if you don't have a testnet wallet, you can just send it to a testnet faucet at this address:</p>
        <p>tb1q349k20q0yft6knyss5cdpcrgmg30taxyt5ggse</p>
        <p>
            Paul will shortly send you a "results" file. Upload it here when he does.
        </p>
        <form method="post" class="box">
            <div class="box__input">
                <svg class="box__icon" xmlns="http://www.w3.org/2000/svg" width="50" height="43" viewBox="0 0 50 43" onclick='document.getElementById( "file_label_2" ).click();'><path d="M48.4 26.5c-.9 0-1.7.7-1.7 1.7v11.6h-43.3v-11.6c0-.9-.7-1.7-1.7-1.7s-1.7.7-1.7 1.7v13.2c0 .9.7 1.7 1.7 1.7h46.7c.9 0 1.7-.7 1.7-1.7v-13.2c0-1-.7-1.7-1.7-1.7zm-24.5 6.1c.3.3.8.5 1.2.5.4 0 .9-.2 1.2-.5l10-11.6c.7-.7.7-1.7 0-2.4s-1.7-.7-2.4 0l-7.1 8.3v-25.3c0-.9-.7-1.7-1.7-1.7s-1.7.7-1.7 1.7v25.3l-7.1-8.3c-.7-.7-1.7-.7-2.4 0s-.7 1.7 0 2.4l10 11.6z"/></svg>
                <input type="file" name="files[]" id="file" class="box__file" data-multiple-caption="{count} files selected" multiple style="display: none;" onchange="if ( this.files[ 0 ].size < 100000 ) {getFile(this);} else {alert( 'File too large, make sure it is less than 100 kilobytes' ); this.value = null;}" />
                <label for="file" id="file_label_2"><strong>Choose a file</strong><span class="box__dragndrop"> or drag it here</span></label>
                <button type="submit" class="box__button">Upload</button>
            </div>        
            <div class="box__uploading">Uploading&hellip;</div>
            <div class="box__success">Done!</div>
            <div class="box__error">Error! <span></span>. <a class="box__restart" role="button">Try again!</a></div>
        </form>
    </div>
    <script>
        var privkey = getRand( 32 );
        var pubkey = nobleSecp256k1.getPublicKey( privkey, true ).substring( 2 );
        window.vickys_key = pubkey;
        $( '.vicky_key' ).innerText = pubkey;
    </script>
    <script>
        $( '.address_verification_reset' ).onclick = () => {
            alert( `Something must have gone wrong so it is not safe to continue. The page will reset.` );
            window.location.reload();
        }
        $( '.address_verification_done' ).onclick = async () => {
            $( '.address_verification_div' ).classList.add( "hidden" );
            $( '.wait_for_sigs_div' ).classList.remove( "hidden" );
        }
    </script>
    <script>
        function getFile(input) {
            if ( 'files' in input && input.files.length > 0 ) {
                handleContent( input.files[0] );
            }
        }

        function handleContent( file ) {
            readFileContent( file ).then( async content => {
                var json = JSON.parse( content );
                if ( "msg_type" in json && json[ "msg_type" ] == "results" ) {
                    var starter_txid = json[ "starter_info" ][ "starter_txid" ];
                    var starter_vout = json[ "starter_info" ][ "starter_vout" ];
                    var starter_amt = json[ "starter_info" ][ "starter_amt" ];
                    var funding_to_challenge_txdata = tapscript.Tx.create({
                      vin: [{
                        txid: starter_txid,
                        vout: starter_vout,
                        prevout: {
                          value: starter_amt,
                          scriptPubKey: tapscript.Address.toScriptPubKey( funding_address )
                        },
                      }],
                      vout: [{
                        value: starter_amt - 500,
                        scriptPubKey: tapscript.Address.toScriptPubKey( challenge_address ),
                      }],
                    });
                    var tree = funding_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                    var selected_script = funding_scripts[ 1 ];
                    var target = tapscript.Tap.encodeScript( selected_script );
                    var pubkey = "ab".repeat( 32 );
                    var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
                    var his_sig = json[ "signatures" ][ "funding_to_challenge_sig" ];
                    var sighash = tapscript.Signer.taproot.hash( funding_to_challenge_txdata, 0, {extension: target} );
                    var his_key = pauls_key;
                    var his_funding_to_challenge_sig_is_good = await nobleSecp256k1.schnorr.verify( his_sig, sighash, his_key );
                    console.log( "his funding to challenge sig is good, right?", his_funding_to_challenge_sig_is_good );
                    if ( !his_funding_to_challenge_sig_is_good ) {
                        alert( `Paul sent you a bad sig so you must not pay him for any work he does. Aborting and restarting the page.` );
                        window.location.reload();
                        return;
                    }
                    //todo: validate Paul's other signatures
                    var funding_to_challenge_sig = tapscript.Signer.taproot.sign( privkey, funding_to_challenge_txdata, 0, { extension: target } );
                    var sigs = [his_sig, funding_to_challenge_sig];
                    sigs.reverse();
                    funding_to_challenge_txdata.vin[0].witness = [ ...sigs, selected_script, cblock ];
                    to_challenge_txhex = tapscript.Tx.encode( funding_to_challenge_txdata ).hex;  
                    to_challenge_txid = tapscript.Tx.util.getTxid( to_challenge_txhex );
                    to_challenge_vout = 0;
                    to_challenge_amt = starter_amt - 500;
                    json[ "preimages_to_reveal" ].forEach( item => preimages_from_paul.push( item ) );
                    preimages_from_paul = removeDuplicates( preimages_from_paul );
                    discardUnusedPreimages();
                    //todo: actually give Vicky a transaction to broadcast here
                    if ( preimages_from_paul.length < number_of_preimages_to_expect ) return alert( "oh no! Go put your counterparty’s money in the bit commitment address!" );
                    //todo: also give Vicky a transaction to broadcast if Paul doesn't do his bit commitments in time
                    //todo: also make the circuits reusable so that Vicky and Paul don't force close in every transaction
                    var preimages_and_their_tapleaves = [];
                    var i; for ( i=0; i<preimages_from_paul.length; i++ ) {
                        var preimage = preimages_from_paul[ i ];
                        var tapleaves_it_is_in = await compareTapleaves( preimage, challenge_scripts );
                        preimages_and_their_tapleaves.push( tapleaves_it_is_in );
                    }
                    expanded_array = [];
                    operations_array.forEach( item => {
                        if ( item[ 0 ] == "INV" ) expanded_array.push( ["OP_NOT"],["OP_NOT"],["OP_NOT"],["OP_NOT"] );
                        if ( item[ 0 ] == "AND" ) expanded_array.push( ["OP_BOOLAND"],["OP_BOOLAND"],["OP_BOOLAND"],["OP_BOOLAND"], ["OP_BOOLAND"],["OP_BOOLAND"],["OP_BOOLAND"],["OP_BOOLAND"] );
                        if ( item[ 0 ] == "XOR" ) expanded_array.push( ["OP_XOR"],["OP_XOR"],["OP_XOR"],["OP_XOR"], ["OP_XOR"],["OP_XOR"],["OP_XOR"],["OP_XOR"] );
                    });
                    expanded_array.push( "multisig" );
                    preimages_and_their_tapleaves.forEach( ( preimage, index ) => {
                        preimage.forEach( num => {
                            expanded_array[ num ].push( preimages_from_paul[ index ] );
                        });
                    });
                    var operation_index; for ( operation_index=0; operation_index<expanded_array.length; operation_index++ ) {
                        var item = expanded_array[ operation_index ];
                        if ( item[ 0 ] == "OP_NOT" && item.length == 3 ) {
                            var hash_order = [];
                            challenge_scripts[ operation_index ].forEach( element => {
                                if ( element.length == 64 ) hash_order.push( element );
                            });
                            if ( operation_index == 3 ) console.log( "hash_order:", hash_order )
                            var preimages_in_order = [];
                            var index; for ( index=0; index<expanded_array[ operation_index ].length; index++ ) {
                                var preimage = expanded_array[ operation_index ][ index ];
                                if ( index ) {
                                    var hash = await sha256( hexToBytes( preimage ) );
                                    hash_order.forEach( ( ordered_hash, hash_index ) => {
                                        if ( ordered_hash == hash ) preimages_in_order[ hash_index ] = preimage;
                                    });
                                }
                            }
                            expanded_array[ operation_index ] = ["OP_NOT", ...preimages_in_order];
                            if ( operation_index == 3 ) console.log( "preimages in order:", preimages_in_order );
                        }
                        if ( item[ 0 ] == "OP_BOOLAND" && item.length == 4 ) {
                            var hash_order = [];
                            challenge_scripts[ operation_index ].forEach( element => {
                                if ( element.length == 64 ) hash_order.push( element );
                            });
                            var preimages_in_order = [];
                            var index; for ( index=0; index<expanded_array[ operation_index ].length; index++ ) {
                                var preimage = expanded_array[ operation_index ][ index ];
                                if ( index ) {
                                    var hash = await sha256( hexToBytes( preimage ) );
                                    hash_order.forEach( ( ordered_hash, hash_index ) => {
                                        if ( ordered_hash == hash ) preimages_in_order[ hash_index ] = preimage;
                                    });
                                }
                            }
                            expanded_array[ operation_index ] = ["OP_BOOLAND", ...preimages_in_order];
                        }
                        if ( item[ 0 ] == "OP_XOR" && item.length == 4 ) {
                            var hash_order = [];
                            challenge_scripts[ operation_index ].forEach( element => {
                                if ( element.length == 64 ) hash_order.push( element );
                            });
                            var preimages_in_order = [];
                            var index; for ( index=0; index<expanded_array[ operation_index ].length; index++ ) {
                                var preimage = expanded_array[ operation_index ][ index ];
                                if ( index ) {
                                    var hash = await sha256( hexToBytes( preimage ) );
                                    hash_order.forEach( ( ordered_hash, hash_index ) => {
                                        if ( ordered_hash == hash ) preimages_in_order[ hash_index ] = preimage;
                                    });
                                }
                            }
                            expanded_array[ operation_index ] = ["OP_XOR", ...preimages_in_order];
                        }
                    }
                    var index; for ( index=0; index<expanded_array.length; index++ ) {
                        var item = expanded_array[ index ];
                        if ( item[ 0 ] == "OP_NOT" && item.length == 3 ) {
                            var i_can_spend = await OP_NOT( item[ 1 ], challenge_scripts[ index ][ 2 ], Number( challenge_scripts[ index ][ 4 ].substring( challenge_scripts[ index ][ 4 ].length - 1 ) ), item[ 2 ], challenge_scripts[ index ][ 8 ], Number( challenge_scripts[ index ][ 10 ].substring( challenge_scripts[ index ][ 10 ].length - 1 ) ) );
                            if ( i_can_spend.startsWith( "you can spend" ) ) {
                                if ( paul_lied ) continue;
                                paul_lied = true;
                                var tree = challenge_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                                var selected_script = challenge_scripts[ index ];
                                var target = tapscript.Tap.encodeScript( selected_script );
                                var pubkey = "ab".repeat( 32 );
                                var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
                                var split_string = i_can_spend.split( " " );
                                //the order they should go in is: output first, so it can be moved to the altstack;
                                //then the input, so it can be processed.
                                var preimages = [ split_string[ 6 ], split_string[ 12 ] ];
                                var destino = $( '.vickys_bitcoin_address' ).value;
                                if ( !destino ) destino = prompt( `Paul broke his promise so you can take his money. Please enter a bitcoin address where you want it to go` );
                                var txdata = tapscript.Tx.create({
                                  vin  : [{
                                    txid: to_challenge_txid,
                                    vout: to_challenge_vout,
                                    prevout: {
                                      value: to_challenge_amt,
                                      scriptPubKey: [ 'OP_1', tpubkey ]
                                    },
                                  }],
                                  vout : [{
                                    value: to_challenge_amt - 500,
                                    scriptPubKey: tapscript.Address.toScriptPubKey( destino ),
                                  }]
                                });
                                var sig = tapscript.Signer.taproot.sign( privkey, txdata, 0, { extension: target } );
                                txdata.vin[ 0 ].witness = [ sig, ...preimages, challenge_scripts[ index ], cblock ];
                                var txhex = tapscript.Tx.encode( txdata ).hex;
                                // alert( i_can_spend + ` -- oh yeah and the index of the tapleaf you can spend with is ${index}\n\n${to_challenge_txhex}\n\n${txhex}` );} else {console.log( `you have the preimages for tapleaf ${index}, which was an OP_NOT tapleaf, but you cannot spend with it, meaning its calculations were done correctly` );
                                pushBTCpmt( to_challenge_txhex, "" );
                                setTimeout( () => {pushBTCpmt( txhex, "" )}, 3000 );
                                $( '.wait_for_sigs_div' ).innerHTML = `<h1>You're in luck!</h1><p>Whoa, Paul broke his promise! That means you got to take his money. Cool! BTW your transaction doing so has already been broadcasted. At any moment, your money should show up in the address you designated.</p>`;
                            }
                        }
                        if ( item[ 0 ] == "OP_BOOLAND" && item.length == 4 ) {
                            var i_can_spend = await OP_BOOLAND( item[ 1 ], challenge_scripts[ index ][ 2 ], Number( challenge_scripts[ index ][ 4 ].substring( challenge_scripts[ index ][ 4 ].length - 1 ) ), item[ 2 ], challenge_scripts[ index ][ 7 ], Number( challenge_scripts[ index ][ 9 ].substring( challenge_scripts[ index ][ 9 ].length - 1 ) ), item[ 3 ], challenge_scripts[ index ][ 13 ], Number( challenge_scripts[ index ][ 15 ].substring( challenge_scripts[ index ][ 15 ].length - 1 ) ) );
                            if ( i_can_spend.startsWith( "you can spend" ) ) {
                                if ( paul_lied ) continue;
                                paul_lied = true;
                                var tree = challenge_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                                var selected_script = challenge_scripts[ index ];
                                var target = tapscript.Tap.encodeScript( selected_script );
                                var pubkey = "ab".repeat( 32 );
                                var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
                                var split_string = i_can_spend.split( " " );
                                //the order they should go in is: output first, so it can be moved to the altstack;
                                //then input 1, as it is processed first; then input 2, as it is processed next.
                                var preimages = [ split_string[ 12 ], split_string[ 6 ], split_string[ 17 ] ];
                                var destino = $( '.vickys_bitcoin_address' ).value;
                                if ( !destino ) destino = prompt( `Paul broke his promise so you can take his money. Please enter a bitcoin address where you want it to go` );
                                var txdata = tapscript.Tx.create({
                                  vin  : [{
                                    txid: to_challenge_txid,
                                    vout: to_challenge_vout,
                                    prevout: {
                                      value: to_challenge_amt,
                                      scriptPubKey: [ 'OP_1', tpubkey ]
                                    },
                                  }],
                                  vout : [{
                                    value: to_challenge_amt - 500,
                                    scriptPubKey: tapscript.Address.toScriptPubKey( destino ),
                                  }]
                                });
                                var sig = tapscript.Signer.taproot.sign( privkey, txdata, 0, { extension: target } );
                                txdata.vin[ 0 ].witness = [ sig, ...preimages, challenge_scripts[ index ], cblock ];
                                var txhex = tapscript.Tx.encode( txdata ).hex;
                                // alert( i_can_spend + ` -- oh yeah and the index of the tapleaf you can spend with is ${index}\n\n${to_challenge_txhex}\n\n${txhex}` );} else {console.log( `you have the preimages for tapleaf ${index}, which was an OP_BOOLAND tapleaf, but you cannot spend with it, meaning its calculations were done correctly` );
                                pushBTCpmt( to_challenge_txhex, "" );
                                setTimeout( () => {pushBTCpmt( txhex, "" )}, 3000 );
                                $( '.wait_for_sigs_div' ).innerHTML = `<h1>You're in luck!</h1><p>Whoa, Paul broke his promise! That means you got to take his money. Cool! BTW your transaction doing so has already been broadcasted. At any moment, your money should show up in the address you designated.</p>`;
                            }
                        }
                        if ( item[ 0 ] == "OP_XOR" && item.length == 4 ) {
                            var i_can_spend = await OP_XOR( item[ 1 ], challenge_scripts[ index ][ 2 ], Number( challenge_scripts[ index ][ 4 ].substring( challenge_scripts[ index ][ 4 ].length - 1 ) ), item[ 2 ], challenge_scripts[ index ][ 7 ], Number( challenge_scripts[ index ][ 9 ].substring( challenge_scripts[ index ][ 9 ].length - 1 ) ), item[ 3 ], challenge_scripts[ index ][ 13 ], Number( challenge_scripts[ index ][ 15 ].substring( challenge_scripts[ index ][ 15 ].length - 1 ) ) );
                            if ( i_can_spend.startsWith( "you can spend" ) ) {
                                if ( paul_lied ) continue;
                                paul_lied = true;
                                var tree = challenge_scripts.map( s => tapscript.Tap.encodeScript( s ) );
                                var selected_script = challenge_scripts[ index ];
                                var target = tapscript.Tap.encodeScript( selected_script );
                                var pubkey = "ab".repeat( 32 );
                                var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { tree, target });
                                var split_string = i_can_spend.split( " " );
                                //the order they should go in is: output first, so it can be moved to the altstack;
                                //then input 1, as it is processed first; then input 2, as it is processed next.
                                var preimages = [ split_string[ 12 ], split_string[ 6 ], split_string[ 17 ] ];
                                var destino = $( '.vickys_bitcoin_address' ).value;
                                if ( !destino ) destino = prompt( `Paul broke his promise so you can take his money. Please enter a bitcoin address where you want it to go` );
                                var txdata = tapscript.Tx.create({
                                  vin  : [{
                                    txid: to_challenge_txid,
                                    vout: to_challenge_vout,
                                    prevout: {
                                      value: to_challenge_amt,
                                      scriptPubKey: [ 'OP_1', tpubkey ]
                                    },
                                  }],
                                  vout : [{
                                    value: to_challenge_amt - 500,
                                    scriptPubKey: tapscript.Address.toScriptPubKey( destino ),
                                  }]
                                });
                                var sig = tapscript.Signer.taproot.sign( privkey, txdata, 0, { extension: target } );
                                txdata.vin[ 0 ].witness = [ sig, ...preimages, challenge_scripts[ index ], cblock ];
                                var txhex = tapscript.Tx.encode( txdata ).hex;
                                // alert( i_can_spend + ` -- oh yeah and the index of the tapleaf you can spend with is ${index}\n\n${to_challenge_txhex}\n\n${txhex}` );} else {console.log( `you have the preimages for tapleaf ${index}, which was an OP_XOR tapleaf, but I cannot spend with it, meaning its calculations were done correctly` );
                                pushBTCpmt( to_challenge_txhex, "" );
                                setTimeout( () => {pushBTCpmt( txhex, "" )}, 3000 );
                                $( '.wait_for_sigs_div' ).innerHTML = `<h1>You're in luck!</h1><p>Whoa, Paul broke his promise! That means you got to take his money. Cool! BTW your transaction doing so has already been broadcasted. At any moment, your money should show up in the address you designated.</p>`;
                            }
                        }
                    }
                    await logInputs();
                    var index; for ( index=0; index<arr.length; index++ ) {
                        var gate = arr[ index ].split( " " ).filter( item => item );
                        if ( gate[ gate.length - 1 ] == "INV" ) {
                            wires[ gate[ 3 ] ] = eval( `INV( wires[ ${gate[ 2 ]} ] )` );
                            //js_version += `wires[ ${gate[ 3 ]} ] = INV( wires[ ${gate[ 2 ]} ] )\n`;
                        }
                        if ( gate[ gate.length - 1 ] == "AND" ) {
                            wires[ gate[ 4 ] ] = eval( `AND( wires[ ${gate[ 2 ]} ], wires[ ${gate[ 3 ]} ] )` );
                            //js_version += `wires[ ${gate[ 4 ]} ] = AND( wires[ ${gate[ 2 ]} ], wires[ ${gate[ 3 ]} ] )\n`;
                        }
                        if ( gate[ gate.length - 1 ] == "XOR" ) {
                            wires[ gate[ 4 ] ] = eval( `XOR( wires[ ${gate[ 2 ]} ], wires[ ${gate[ 3 ]} ] )` );
                            //js_version += `wires[ ${gate[ 4 ]} ] = AND( wires[ ${gate[ 2 ]} ], wires[ ${gate[ 3 ]} ] )\n`;
                        }
                    }
                    var input_1 = ``;
                    var input_2 = ``;
                    var output = ``;
                    var i; for ( i=0; i<number_of_inputs; i++ ) {
                        input_1 += String( wires[ i ] );
                    }
                    if ( number_of_inputs_2 ) {
                        var i; for ( i=0; i<number_of_inputs_2; i++ ) {
                            input_2 += String( wires[ i + number_of_inputs ] );
                        }
                    }
                    var i; for ( i=number_of_preimages_to_expect-number_of_outputs; i<number_of_preimages_to_expect; i++ ) {
                        output += String( wires[ i ] );
                    }
                    console.log( "inputs and outputs:", input_1, input_2, output );
                    if ( paul_lied ) return;
                    if ( program == "zero checker" ) {
                        var is_or_is_not = "is";
                        if ( !Number( output ) ) is_or_is_not = "is not";
                        alert( `The prover kept his promise. He promised ${pauls_promise.toLowerCase()}. This is what he sent you:\n\n${input_1}\n\nBitvm checked whether that string consists of all zeros and this was its result: ${!!Number( output )} -- so it determined the string ${is_or_is_not} all zeros. Meaning not only do *you* know the prover kept his promise, your bitcoin transaction knows it too. This completes the procedure; refresh your page to try again.` );
                    }
                    if ( program == "size checker" ) {
                        var partial_promise = pauls_promise[ 1 ].toLowerCase();
                        if ( partial_promise == "not bigger" ) partial_promise = "equal to or less";
                        alert( `The prover kept his promise. He promised to give you two numbers, the first of which is ${partial_promise} than the second. These are the two numbers he sent you:\n\n${parseInt( reverseString( input_1 ), 2 )} and ${parseInt( reverseString( input_2 ), 2 )}\n\nBitvm checked whether the first is ${partial_promise} than the second and this was its result: true -- so it determined the first is ${partial_promise} than the second. Meaning not only do *you* know the prover kept his promise, your bitcoin transaction knows it too. This completes the procedure; refresh your page to try again.` );
                    }
                    if ( program == "addition" ) {
                        var do_or_dont = "";
                        console.log( input_1, input_2, output, parseInt( input_1, 2 ), parseInt( input_2, 2 ), parseInt( output, 2 ), parseInt( input_1, 2 ) + parseInt( input_2, 2 ), parseInt( input_1, 2 ) + parseInt( input_2, 2 ) == parseInt( output, 2 ) );
                        if ( parseInt( input_1, 2 ) + parseInt( input_2, 2 ) != parseInt( output, 2 ) ) do_or_dont = "don't ";
                        alert( `The prover kept his promise. He promised to give you two numbers that ${do_or_dont}add up to ${parseInt( output, 2 )}. The first number he gave you is ${parseInt( input_1, 2 )} and the second is ${parseInt( input_2, 2 )}.\n\nBitvm checked whether they add up to ${parseInt( output, 2 )} and it determined the equation is: ${parseInt( input_1, 2 ) + parseInt( input_2, 2 ) == parseInt( output, 2 )} -- just as the prover promised. Meaning not only do *you* know the prover kept his promise, your bitcoin transaction knows it too. This completes the procedure; refresh your page to try again.` );
                    }
                    return;
                }
                console.log( json );
                program = json[ "program" ];
                initial_commitment_hashes = json[ "initial_commitment_hashes" ];
                pauls_key = json[ "pauls_key" ];
                subsequent_commitment_hashes = json[ "subsequent_commitment_hashes" ];
                pauls_promise = json[ "promise" ];
                var pubkey = window.vickys_key;
                bit_commitment_address = generateBitCommitmentAddress( pubkey );
                anti_contradiction_address = generateAntiContradictionAddress( pubkey );
                funding_address = generateFundingAddress( pubkey );
                if ( program == "zero checker" ) {
                    arrprep = `
                    127 191
                    1 64 
                    1 1 

                    1 1 63 65 INV
                    1 1 60 64 INV
                    2 1 65 64 69 AND
                    1 1 62 67 INV
                    1 1 61 66 INV
                    2 1 67 66 68 AND
                    2 1 69 68 77 AND
                    1 1 51 71 INV
                    1 1 48 70 INV
                    2 1 71 70 75 AND
                    1 1 50 73 INV
                    1 1 49 72 INV
                    2 1 73 72 74 AND
                    2 1 75 74 76 AND
                    2 1 77 76 93 AND
                    1 1 59 79 INV
                    1 1 56 78 INV
                    2 1 79 78 83 AND
                    1 1 58 81 INV
                    1 1 57 80 INV
                    2 1 81 80 82 AND
                    2 1 83 82 91 AND
                    1 1 55 85 INV
                    1 1 52 84 INV
                    2 1 85 84 89 AND
                    1 1 54 87 INV
                    1 1 53 86 INV
                    2 1 87 86 88 AND
                    2 1 89 88 90 AND
                    2 1 91 90 92 AND
                    2 1 93 92 125 AND
                    1 1 15 95 INV
                    1 1 12 94 INV
                    2 1 95 94 99 AND
                    1 1 14 97 INV
                    1 1 13 96 INV
                    2 1 97 96 98 AND
                    2 1 99 98 107 AND
                    1 1 3 101 INV
                    1 1 0 100 INV
                    2 1 101 100 105 AND
                    1 1 2 103 INV
                    1 1 1 102 INV
                    2 1 103 102 104 AND
                    2 1 105 104 106 AND
                    2 1 107 106 123 AND
                    1 1 11 109 INV
                    1 1 8 108 INV
                    2 1 109 108 113 AND
                    1 1 10 111 INV
                    1 1 9 110 INV
                    2 1 111 110 112 AND
                    2 1 113 112 121 AND
                    1 1 7 115 INV
                    1 1 4 114 INV
                    2 1 115 114 119 AND
                    1 1 6 117 INV
                    1 1 5 116 INV
                    2 1 117 116 118 AND
                    2 1 119 118 120 AND
                    2 1 121 120 122 AND
                    2 1 123 122 124 AND
                    2 1 125 124 189 AND
                    1 1 47 127 INV
                    1 1 44 126 INV
                    2 1 127 126 131 AND
                    1 1 46 129 INV
                    1 1 45 128 INV
                    2 1 129 128 130 AND
                    2 1 131 130 139 AND
                    1 1 35 133 INV
                    1 1 32 132 INV
                    2 1 133 132 137 AND
                    1 1 34 135 INV
                    1 1 33 134 INV
                    2 1 135 134 136 AND
                    2 1 137 136 138 AND
                    2 1 139 138 155 AND
                    1 1 43 141 INV
                    1 1 40 140 INV
                    2 1 141 140 145 AND
                    1 1 42 143 INV
                    1 1 41 142 INV
                    2 1 143 142 144 AND
                    2 1 145 144 153 AND
                    1 1 39 147 INV
                    1 1 36 146 INV
                    2 1 147 146 151 AND
                    1 1 38 149 INV
                    1 1 37 148 INV
                    2 1 149 148 150 AND
                    2 1 151 150 152 AND
                    2 1 153 152 154 AND
                    2 1 155 154 187 AND
                    1 1 31 157 INV
                    1 1 28 156 INV
                    2 1 157 156 161 AND
                    1 1 30 159 INV
                    1 1 29 158 INV
                    2 1 159 158 160 AND
                    2 1 161 160 169 AND
                    1 1 19 163 INV
                    1 1 16 162 INV
                    2 1 163 162 167 AND
                    1 1 18 165 INV
                    1 1 17 164 INV
                    2 1 165 164 166 AND
                    2 1 167 166 168 AND
                    2 1 169 168 185 AND
                    1 1 27 171 INV
                    1 1 24 170 INV
                    2 1 171 170 175 AND
                    1 1 26 173 INV
                    1 1 25 172 INV
                    2 1 173 172 174 AND
                    2 1 175 174 183 AND
                    1 1 23 177 INV
                    1 1 20 176 INV
                    2 1 177 176 181 AND
                    1 1 22 179 INV
                    1 1 21 178 INV
                    2 1 179 178 180 AND
                    2 1 181 180 182 AND
                    2 1 183 182 184 AND
                    2 1 185 184 186 AND
                    2 1 187 186 188 AND
                    2 1 189 188 190 AND
                    `;
                }
                if ( program == "size checker" ) {
                    arrprep = `
                    312 376
                    2 32 32
                    1 1

                    1 1 38 348 INV
                    1 1 27 352 INV
                    1 1 49 361 INV
                    1 1 45 346 INV
                    1 1 41 363 INV
                    1 1 50 354 INV
                    1 1 63 373 INV
                    1 1 10 259 INV
                    1 1 44 350 INV
                    1 1 7 369 INV
                    1 1 4 166 INV
                    1 1 54 345 INV
                    1 1 6 267 INV
                    1 1 52 355 INV
                    1 1 28 276 INV
                    1 1 39 366 INV
                    1 1 51 229 INV
                    1 1 20 347 INV
                    1 1 59 372 INV
                    1 1 19 289 INV
                    1 1 9 336 INV
                    1 1 15 342 INV
                    1 1 3 353 INV
                    1 1 17 367 INV
                    1 1 5 237 INV
                    1 1 24 164 INV
                    1 1 14 281 INV
                    1 1 60 343 INV
                    1 1 55 231 INV
                    1 1 31 371 INV
                    1 1 2 370 INV
                    1 1 57 364 INV
                    1 1 16 365 INV
                    1 1 62 357 INV
                    1 1 42 359 INV
                    1 1 58 341 INV
                    1 1 26 269 INV
                    1 1 34 344 INV
                    1 1 12 252 INV
                    1 1 23 291 INV
                    1 1 25 242 INV
                    1 1 30 275 INV
                    1 1 1 263 INV
                    1 1 46 338 INV
                    1 1 48 337 INV
                    1 1 8 199 INV
                    1 1 22 334 INV
                    1 1 32 333 INV
                    1 1 18 368 INV
                    1 1 11 360 INV
                    1 1 21 339 INV
                    1 1 13 362 INV
                    1 1 47 340 INV
                    1 1 61 335 INV
                    1 1 37 358 INV
                    1 1 29 374 INV
                    1 1 35 351 INV
                    1 1 53 349 INV
                    1 1 43 356 INV
                    2 1 333 0 292 AND
                    2 1 334 54 290 AND
                    2 1 335 29 293 AND
                    2 1 336 41 220 AND
                    2 1 337 16 294 AND
                    2 1 338 14 299 AND
                    2 1 339 53 298 AND
                    2 1 340 15 297 AND
                    2 1 341 26 301 AND
                    2 1 342 47 295 AND
                    2 1 343 28 302 AND
                    2 1 344 2 303 AND
                    2 1 345 22 304 AND
                    2 1 346 13 305 AND
                    2 1 347 52 296 AND
                    2 1 348 6 306 AND
                    2 1 349 21 307 AND
                    2 1 350 12 308 AND
                    2 1 351 3 309 AND
                    2 1 352 59 310 AND
                    2 1 353 35 311 AND
                    2 1 354 18 312 AND
                    2 1 355 20 313 AND
                    2 1 356 11 314 AND
                    2 1 357 30 316 AND
                    2 1 358 5 317 AND
                    2 1 359 10 318 AND
                    2 1 360 43 319 AND
                    2 1 361 17 320 AND
                    2 1 362 45 300 AND
                    2 1 363 9 321 AND
                    2 1 364 25 322 AND
                    2 1 365 48 323 AND
                    2 1 366 7 324 AND
                    2 1 367 49 325 AND
                    2 1 368 50 288 AND
                    2 1 369 39 315 AND
                    2 1 370 34 326 AND
                    2 1 231 23 328 AND
                    2 1 371 63 329 AND
                    2 1 372 27 330 AND
                    2 1 373 31 331 AND
                    2 1 229 19 332 AND
                    2 1 374 61 327 AND
                    2 1 288 289 284 AND
                    2 1 290 291 286 AND
                    2 1 292 1 287 AND
                    1 1 290 285 INV
                    1 1 293 272 INV
                    1 1 294 77 INV
                    1 1 295 186 INV
                    1 1 296 279 INV
                    1 1 297 280 INV
                    1 1 298 278 INV
                    1 1 299 282 INV
                    1 1 300 188 INV
                    1 1 301 257 INV
                    1 1 302 273 INV
                    1 1 303 140 INV
                    1 1 304 233 INV
                    1 1 305 251 INV
                    1 1 306 268 INV
                    1 1 307 254 INV
                    1 1 308 255 INV
                    1 1 309 109 INV
                    1 1 310 133 INV
                    1 1 292 262 INV
                    1 1 311 103 INV
                    1 1 312 239 INV
                    1 1 313 197 INV
                    1 1 314 258 INV
                    1 1 315 135 INV
                    1 1 316 277 INV
                    1 1 317 240 INV
                    1 1 318 261 INV
                    1 1 319 154 INV
                    1 1 320 271 INV
                    1 1 321 260 INV
                    1 1 322 235 INV
                    1 1 323 265 INV
                    1 1 324 266 INV
                    1 1 325 264 INV
                    1 1 288 283 INV
                    1 1 326 126 INV
                    1 1 327 184 INV
                    1 1 328 253 INV
                    1 1 329 274 INV
                    1 1 330 256 INV
                    1 1 331 124 INV
                    1 1 332 270 INV
                    2 1 251 252 243 AND
                    2 1 253 254 232 AND
                    2 1 251 255 244 AND
                    2 1 256 257 234 AND
                    2 1 258 259 245 AND
                    2 1 260 199 223 AND
                    2 1 258 261 219 AND
                    2 1 262 263 246 AND
                    2 1 264 265 247 AND
                    2 1 266 267 224 AND
                    2 1 266 268 236 AND
                    2 1 256 269 222 AND
                    2 1 270 271 238 AND
                    2 1 272 273 218 AND
                    2 1 274 275 225 AND
                    2 1 272 276 226 AND
                    2 1 274 277 142 AND
                    2 1 278 279 248 AND
                    2 1 280 281 227 AND
                    2 1 280 282 144 AND
                    2 1 283 19 249 AND
                    2 1 260 40 221 AND
                    1 1 284 228 INV
                    2 1 285 23 250 AND
                    1 1 286 230 INV
                    1 1 287 241 INV
                    2 1 142 218 113 AND
                    2 1 219 220 206 AND
                    2 1 219 221 198 AND
                    2 1 222 58 207 AND
                    2 1 219 223 208 AND
                    2 1 224 38 209 AND
                    2 1 225 62 210 AND
                    2 1 226 60 211 AND
                    2 1 227 46 212 AND
                    2 1 228 229 213 AND
                    2 1 230 231 214 AND
                    2 1 232 233 196 AND
                    2 1 234 235 201 AND
                    2 1 236 237 204 AND
                    2 1 238 239 75 AND
                    2 1 236 240 202 AND
                    2 1 241 33 215 AND
                    2 1 234 242 205 AND
                    2 1 243 44 216 AND
                    2 1 144 244 85 AND
                    2 1 245 42 217 AND
                    1 1 246 180 INV
                    1 1 247 200 INV
                    1 1 248 203 INV
                    1 1 249 176 INV
                    1 1 250 182 INV
                    2 1 196 197 73 AND
                    2 1 198 199 189 AND
                    2 1 75 200 190 AND
                    2 1 201 164 191 AND
                    2 1 202 166 192 AND
                    2 1 196 203 193 AND
                    2 1 201 56 163 AND
                    2 1 204 37 194 AND
                    2 1 202 36 165 AND
                    2 1 205 57 195 AND
                    1 1 206 173 INV
                    1 1 198 177 INV
                    1 1 207 156 INV
                    1 1 208 178 INV
                    1 1 209 158 INV
                    1 1 210 115 INV
                    1 1 211 183 INV
                    1 1 212 185 INV
                    1 1 213 175 INV
                    1 1 214 181 INV
                    1 1 215 179 INV
                    1 1 216 187 INV
                    1 1 217 174 INV
                    2 1 163 164 151 AND
                    2 1 165 166 152 AND
                    2 1 173 174 137 AND
                    2 1 175 176 167 AND
                    2 1 177 178 168 AND
                    2 1 179 180 169 AND
                    2 1 181 182 170 AND
                    2 1 183 184 171 AND
                    2 1 185 186 80 AND
                    2 1 187 188 172 AND
                    1 1 189 153 INV
                    1 1 190 146 INV
                    1 1 191 160 INV
                    1 1 192 162 INV
                    1 1 193 149 INV
                    1 1 163 159 INV
                    1 1 194 157 INV
                    1 1 165 161 INV
                    1 1 195 155 INV
                    1 1 151 132 INV
                    1 1 152 134 INV
                    2 1 153 154 136 AND
                    2 1 155 156 120 AND
                    2 1 157 158 122 AND
                    2 1 159 160 147 AND
                    2 1 161 162 150 AND
                    1 1 167 145 INV
                    1 1 168 91 INV
                    1 1 169 139 INV
                    1 1 170 148 INV
                    1 1 171 141 INV
                    1 1 172 143 INV
                    2 1 132 133 119 AND
                    2 1 134 135 121 AND
                    2 1 136 137 88 AND
                    2 1 139 140 129 AND
                    2 1 141 142 130 AND
                    2 1 143 144 131 AND
                    2 1 145 146 138 AND
                    1 1 147 128 INV
                    2 1 148 149 111 AND
                    1 1 150 99 INV
                    2 1 119 120 116 AND
                    2 1 121 122 94 AND
                    2 1 128 113 71 AND
                    1 1 129 125 INV
                    1 1 130 123 INV
                    1 1 131 82 INV
                    1 1 138 127 INV
                    1 1 116 112 INV
                    2 1 123 124 114 AND
                    2 1 125 126 117 AND
                    2 1 127 73 118 AND
                    2 1 112 113 106 AND
                    2 1 114 115 68 AND
                    1 1 117 108 INV
                    1 1 118 110 INV
                    1 1 106 97 INV
                    2 1 108 109 107 AND
                    2 1 110 111 105 AND
                    1 1 105 104 INV
                    1 1 107 102 INV
                    2 1 102 103 100 AND
                    2 1 104 71 101 AND
                    1 1 100 98 INV
                    1 1 101 96 INV
                    2 1 96 97 66 AND
                    2 1 98 99 95 AND
                    1 1 95 93 INV
                    2 1 93 94 92 AND
                    1 1 92 90 INV
                    2 1 90 91 89 AND
                    1 1 89 87 INV
                    2 1 87 88 86 AND
                    1 1 86 84 INV
                    2 1 84 85 83 AND
                    1 1 83 81 INV
                    2 1 81 82 79 AND
                    2 1 79 80 78 AND
                    1 1 78 76 INV
                    2 1 76 77 74 AND
                    2 1 74 75 72 AND
                    2 1 72 73 70 AND
                    2 1 70 71 69 AND
                    1 1 69 67 INV
                    2 1 67 68 65 AND
                    2 1 65 66 64 AND
                    1 1 64 375 INV
                    `;
                }
                if ( program == "addition" ) {
                    arrprep = `
                    154 218
                    2 32 32
                    1 32

                    2 1 31 63 217 XOR
                    2 1 31 63 65 AND
                    2 1 30 65 66 XOR
                    2 1 62 66 216 XOR
                    2 1 62 65 68 XOR
                    2 1 66 68 69 AND
                    2 1 65 69 70 XOR
                    2 1 29 70 71 XOR
                    2 1 61 71 215 XOR
                    2 1 61 70 73 XOR
                    2 1 71 73 74 AND
                    2 1 70 74 75 XOR
                    2 1 28 75 76 XOR
                    2 1 60 76 214 XOR
                    2 1 60 75 78 XOR
                    2 1 76 78 79 AND
                    2 1 75 79 80 XOR
                    2 1 27 80 81 XOR
                    2 1 59 81 213 XOR
                    2 1 59 80 83 XOR
                    2 1 81 83 84 AND
                    2 1 80 84 85 XOR
                    2 1 26 85 86 XOR
                    2 1 58 86 212 XOR
                    2 1 58 85 88 XOR
                    2 1 86 88 89 AND
                    2 1 85 89 90 XOR
                    2 1 25 90 91 XOR
                    2 1 57 91 211 XOR
                    2 1 57 90 93 XOR
                    2 1 91 93 94 AND
                    2 1 90 94 95 XOR
                    2 1 24 95 96 XOR
                    2 1 56 96 210 XOR
                    2 1 56 95 98 XOR
                    2 1 96 98 99 AND
                    2 1 95 99 100 XOR
                    2 1 23 100 101 XOR
                    2 1 55 101 209 XOR
                    2 1 55 100 103 XOR
                    2 1 101 103 104 AND
                    2 1 100 104 105 XOR
                    2 1 22 105 106 XOR
                    2 1 54 106 208 XOR
                    2 1 54 105 108 XOR
                    2 1 106 108 109 AND
                    2 1 105 109 110 XOR
                    2 1 21 110 111 XOR
                    2 1 53 111 207 XOR
                    2 1 53 110 113 XOR
                    2 1 111 113 114 AND
                    2 1 110 114 115 XOR
                    2 1 20 115 116 XOR
                    2 1 52 116 206 XOR
                    2 1 52 115 118 XOR
                    2 1 116 118 119 AND
                    2 1 115 119 120 XOR
                    2 1 19 120 121 XOR
                    2 1 51 121 205 XOR
                    2 1 51 120 123 XOR
                    2 1 121 123 124 AND
                    2 1 120 124 125 XOR
                    2 1 18 125 126 XOR
                    2 1 50 126 204 XOR
                    2 1 50 125 128 XOR
                    2 1 126 128 129 AND
                    2 1 125 129 130 XOR
                    2 1 17 130 131 XOR
                    2 1 49 131 203 XOR
                    2 1 49 130 133 XOR
                    2 1 131 133 134 AND
                    2 1 130 134 135 XOR
                    2 1 16 135 136 XOR
                    2 1 48 136 202 XOR
                    2 1 48 135 138 XOR
                    2 1 136 138 139 AND
                    2 1 135 139 140 XOR
                    2 1 15 140 141 XOR
                    2 1 47 141 201 XOR
                    2 1 47 140 143 XOR
                    2 1 141 143 144 AND
                    2 1 140 144 145 XOR
                    2 1 14 145 146 XOR
                    2 1 46 146 200 XOR
                    2 1 46 145 148 XOR
                    2 1 146 148 149 AND
                    2 1 145 149 150 XOR
                    2 1 13 150 151 XOR
                    2 1 45 151 199 XOR
                    2 1 45 150 153 XOR
                    2 1 151 153 154 AND
                    2 1 150 154 155 XOR
                    2 1 12 155 156 XOR
                    2 1 44 156 198 XOR
                    2 1 44 155 158 XOR
                    2 1 156 158 159 AND
                    2 1 155 159 160 XOR
                    2 1 11 160 161 XOR
                    2 1 43 161 197 XOR
                    2 1 43 160 163 XOR
                    2 1 161 163 164 AND
                    2 1 160 164 165 XOR
                    2 1 10 165 166 XOR
                    2 1 42 166 196 XOR
                    2 1 42 165 168 XOR
                    2 1 166 168 169 AND
                    2 1 165 169 170 XOR
                    2 1 9 170 171 XOR
                    2 1 41 171 195 XOR
                    2 1 41 170 173 XOR
                    2 1 171 173 174 AND
                    2 1 170 174 175 XOR
                    2 1 8 175 176 XOR
                    2 1 40 176 194 XOR
                    2 1 40 175 178 XOR
                    2 1 176 178 179 AND
                    2 1 175 179 180 XOR
                    2 1 7 180 181 XOR
                    2 1 39 181 193 XOR
                    2 1 39 180 183 XOR
                    2 1 181 183 184 AND
                    2 1 180 184 185 XOR
                    2 1 6 185 64 XOR
                    2 1 38 64 192 XOR
                    2 1 38 185 112 XOR
                    2 1 64 112 137 AND
                    2 1 185 137 162 XOR
                    2 1 5 162 87 XOR
                    2 1 37 87 191 XOR
                    2 1 37 162 182 XOR
                    2 1 87 182 177 AND
                    2 1 162 177 172 XOR
                    2 1 4 172 167 XOR
                    2 1 36 167 190 XOR
                    2 1 36 172 157 XOR
                    2 1 167 157 152 AND
                    2 1 172 152 147 XOR
                    2 1 3 147 142 XOR
                    2 1 35 142 189 XOR
                    2 1 35 147 132 XOR
                    2 1 142 132 127 AND
                    2 1 147 127 122 XOR
                    2 1 2 122 117 XOR
                    2 1 34 117 188 XOR
                    2 1 34 122 107 XOR
                    2 1 117 107 102 AND
                    2 1 122 102 97 XOR
                    2 1 1 97 92 XOR
                    2 1 33 92 187 XOR
                    2 1 33 97 82 XOR
                    2 1 92 82 77 AND
                    2 1 97 77 72 XOR
                    2 1 0 32 67 XOR
                    2 1 72 67 186 XOR
                    `;
                }
                makeBristolArray();
                await copyOfSetOperationsArray();
                copy_of_operations_array.forEach( ( operation, index ) => {
                    if ( operation[ 0 ] == "INV" ) copy_of_subsequent_commitment_preimages.push( [ operation[ 2 ][ 1 ], operation[ 2 ][ 2 ] ] );
                    if ( operation[ 0 ] == "INV" ) copy_of_subsequent_commitment_hashes.push( [ operation[ 4 ][ 1 ], operation[ 4 ][ 2 ] ] );
                    if ( operation[ 0 ] == "AND" ) copy_of_subsequent_commitment_preimages.push( [ operation[ 3 ][ 1 ], operation[ 3 ][ 2 ] ] );
                    if ( operation[ 0 ] == "AND" ) copy_of_subsequent_commitment_hashes.push( [ operation[ 6 ][ 1 ], operation[ 6 ][ 2 ] ] );
                    if ( operation[ 0 ] == "XOR" ) copy_of_subsequent_commitment_preimages.push( [ operation[ 3 ][ 1 ], operation[ 3 ][ 2 ] ] );
                    if ( operation[ 0 ] == "XOR" ) copy_of_subsequent_commitment_hashes.push( [ operation[ 6 ][ 1 ], operation[ 6 ][ 2 ] ] );
                });
                await setOperationsArray();
                //Vicky needs to take json[ "output_preimages" ] and add it to
                //preimages_from_paul, but only if she sees that it actually corresponds
                //to the hashes in the last n wires, n being the number of output wires
                //she expects
                var questionable_preimages = json[ "output_preimages" ];
                questionable_preimages = removeDuplicates( questionable_preimages );
                var questionable_hashes = [];
                var i; for ( i=0; i<questionable_preimages.length; i++ ) {
                    var hash = await sha256( hexToBytes( questionable_preimages[ i ] ) );
                    questionable_hashes.push( hash );
                }
                var preimages_found = 0;
                var output = ``;
                if ( wire_hashes.length != number_of_preimages_to_expect ) {
                    alert( `The program they sent you is invalid. Aborting and starting over.` );
                    window.location.reload();
                    return;
                }
                var i; for ( i=number_of_preimages_to_expect-number_of_outputs; i<number_of_preimages_to_expect; i++ ) {
                    wire_hashes[ i ].every( ( expected_hash, index ) => {
                        var j; for ( j=0; j<questionable_hashes.length; j++ ) {
                            if ( expected_hash == questionable_hashes[ j ] ) {
                                preimages_found = preimages_found + 1;
                                output += String( index );
                                return;
                            }
                        }
                        return true;
                    });
                }
                if ( preimages_found != number_of_outputs ) {
                    alert( `The prover sent you bad info. Aborting. Number of preimages you expected: ${number_of_outputs} Number of preimages you got: ${preimages_found}` );
                    window.location.reload();
                    return;
                }
                questionable_preimages.forEach( item => preimages_from_paul.push( item ) );
                var message = `Someone wants to run a program with you called "${program}."`;
                if ( program == "zero checker" ) {
                    var is_or_is_not = "is";
                    if ( !Number( output ) ) is_or_is_not = "is not";
                    message += ` They promise to send you a string which ${is_or_is_not} just a bunch of zeros. They'll put up a bond to show they mean it, and if they break their promise, you can prove they lied and take their money.`
                }
                if ( program == "size checker" ) {
                    var partial_promise = pauls_promise[ 1 ].toLowerCase();
                    if ( partial_promise == "not bigger" ) partial_promise = "equal to or less";
                    message += ` They promise to send you two numbers, the first of which is ${partial_promise} than the second. They'll put up a bond to show they mean it, and if they break their promise, you can prove they lied and take their money.`
                }
                if ( program == "addition" ) {
                    message += ` They promise to send you two numbers which add up to ${parseInt( output, 2 )}. They'll put up a bond to show they mean it, and if they break their promise, you can prove they lied and take their money.`
                }
                message += ` Do you want to try it?`;
                var conf = confirm( message );
                if ( !conf ) {
                    window.location.reload();
                    return;
                }
                challenge_address = generateChallengeAddress( pubkey );
                var html = `
                    <p>Funding address: ${funding_address}</p>
                    <p>Bit commitment address: ${bit_commitment_address}</p>
                    <p>Anti contradiction address: ${anti_contradiction_address}</p>
                    <p>Challenge address: ${challenge_address}</p>
                `;
                $( '.address_validation' ).innerHTML = html;
                $( '.address_verification_div' ).classList.remove( "hidden" );
                $( '#uploader_div' ).classList.add( "hidden" );
                document.getElementsByClassName( "box" )[ 0 ].classList.add( "is-success" );
            }).catch( error => console.log( error ) );
        }

        function readFileContent( file ) {
            var reader = new FileReader();
            return new Promise( ( resolve, reject ) => {
                reader.onload = event => resolve( event.target.result );
                reader.onerror = error => reject( error );
                reader.readAsText( file );
            })
        }
    </script>
    <script>

        'use strict';

        ;( function ( document, window, index )
        {
            // feature detection for drag&drop upload
            var isAdvancedUpload = function()
                {
                    var div = document.createElement( 'div' );
                    return ( ( 'draggable' in div ) || ( 'ondragstart' in div && 'ondrop' in div ) ) && 'FormData' in window && 'FileReader' in window;
                }();

            // applying the effect for every form
            var forms = document.querySelectorAll( '.box' );
            Array.prototype.forEach.call( forms, function( form )
            {
                var input        = form.querySelector( 'input[type="file"]' ),
                    label        = form.querySelector( 'label' ),
                    errorMsg     = form.querySelector( '.box__error span' ),
                    restart      = form.querySelectorAll( '.box__restart' ),
                    droppedFiles = false,
                    showFiles    = function( files )
                    {
                        label.textContent = files.length > 1 ? ( '' ).replace( '{count}', files.length ) : files[ 0 ].name;
                    },
                    triggerFormSubmit = function()
                    {
                        var event = document.createEvent( 'HTMLEvents' );
                        //event.initEvent( 'submit', true, false );
                        //form.dispatchEvent( event );
                    };

                // letting the server side to know we are going to make an Ajax request
                var ajaxFlag = document.createElement( 'input' );
                ajaxFlag.setAttribute( 'type', 'hidden' );
                ajaxFlag.setAttribute( 'name', 'ajax' );
                ajaxFlag.setAttribute( 'value', 1 );
                form.appendChild( ajaxFlag );

                // automatically submit the form on file select
                input.addEventListener( 'change', function( e )
                {
                    showFiles( e.target.files );

                    triggerFormSubmit();

                });

                // drag&drop files if the feature is available
                if( isAdvancedUpload )
                {
                    form.classList.add( 'has-advanced-upload' ); // letting the CSS part to know drag&drop is supported by the browser

                    [ 'drag', 'dragstart', 'dragend', 'dragover', 'dragenter', 'dragleave', 'drop' ].forEach( function( event )
                    {
                        form.addEventListener( event, function( e )
                        {
                            // preventing the unwanted behaviours
                            e.preventDefault();
                            e.stopPropagation();
                        });
                    });
                    [ 'dragover', 'dragenter' ].forEach( function( event )
                    {
                        form.addEventListener( event, function()
                        {
                            form.classList.add( 'is-dragover' );
                        });
                    });
                    [ 'dragleave', 'dragend', 'drop' ].forEach( function( event )
                    {
                        form.addEventListener( event, function()
                        {
                            form.classList.remove( 'is-dragover' );
                        });
                    });
                    form.addEventListener( 'drop', function( e )
                    {
                        droppedFiles = e.dataTransfer.files; // the files that were dropped
                        showFiles( droppedFiles );
                        setTimeout( function() {
                            form.classList.remove( 'is-uploading' );
                            form.classList.add( 'is-success' );
                        }, 300 );
                        handleContent( droppedFiles[0] );
                        //getFile( document.getElementById( "file" ) );                        
                        triggerFormSubmit();
                    });
                }

                // if the form was submitted
                form.addEventListener( 'submit', function( e )
                {
                    // preventing the duplicate submissions if the current one is in progress
                    if( form.classList.contains( 'is-uploading' ) ) return false;

                    form.classList.add( 'is-uploading' );
                    form.classList.remove( 'is-error' );

                    if( isAdvancedUpload ) // ajax file upload for modern browsers
                    {
                        e.preventDefault();
                        setTimeout( function() {
                            form.classList.remove( 'is-uploading' );
                            form.classList.add( 'is-success' );
                        }, 300 );
                    }
                    else // fallback Ajax solution upload for older browsers
                    {
                        var iframeName  = 'uploadiframe' + new Date().getTime(),
                            iframe      = document.createElement( 'iframe' );

                            $iframe     = $( '<iframe name="' + iframeName + '" style="display: none;"></iframe>' );

                        iframe.setAttribute( 'name', iframeName );
                        iframe.style.display = 'none';

                        document.body.appendChild( iframe );
                        form.setAttribute( 'target', iframeName );

                        iframe.addEventListener( 'load', function()
                        {
                            //var data = JSON.parse( iframe.contentDocument.body.innerHTML );
                            setTimeout( function() {
                                form.classList.remove( 'is-uploading' );
                                form.classList.add( 'is-success' );
                            }, 300 );
                            //form.classList.remove( 'is-uploading' )
                            //form.classList.add( data.success == true ? 'is-success' : 'is-error' )
                            form.removeAttribute( 'target' );
                            //if( !data.success ) errorMsg.textContent = data.error;
                            iframe.parentNode.removeChild( iframe );
                        });
                    }
                });

                // restart the form if has a state of error/success
                Array.prototype.forEach.call( restart, function( entry )
                {
                    entry.addEventListener( 'click', function( e )
                    {
                        e.preventDefault();
                        form.classList.remove( 'is-error', 'is-success' );
                        input.click();
                    });
                });

                // Firefox focus bug fix for file input
                input.addEventListener( 'focus', function(){ input.classList.add( 'has-focus' ); });
                input.addEventListener( 'blur', function(){ input.classList.remove( 'has-focus' ); });

            });
        }( document, window, 0 ));

    </script>
    <script>
        function isValidJson( content ) {
                try {  
                    var json = JSON.parse( content );
                } catch ( e ) {
                    return false;  
                }
                return true;
        }
        function getData( url ) {
            return new Promise( async function( resolve, reject ) {
                function inner_get( url ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.open( "GET", url, true );
                    xhttp.send();
                    return xhttp;
                }
                var data = inner_get( url );
                data.onerror = function( e ) {
                    resolve( "error" );
                }
                async function isResponseReady() {
                    return new Promise( function( resolve2, reject ) {
                        if ( !data.responseText || data.readyState != 4 ) {
                            setTimeout( async function() {
                                var msg = await isResponseReady();
                                resolve2( msg );
                            }, 1 );
                        } else {
                            resolve2( data.responseText );
                        }
                    });
                }
                var returnable = await isResponseReady();
                resolve( returnable );
            });
        }
        function pushBTCpmt( rawtx ) {
            var xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function() {
                if ( this.readyState == 4 && ( this.status > 199 && this.status < 300 ) ) {
                    var response = this.responseText;
                    console.log( "Your transaction was broadcasted, your txid is: " + response );
                }
            };
            xhttp.open( "POST", "https://mutinynet.com/api/tx", true );
            xhttp.send( rawtx );
        }
    </script>
    <script>
        function modalVanish() {
            document.getElementById( "black-bg" ).style.display = "none";
            document.getElementById( "modal" ).style.display = "none";
        }
    </script>
    <div id="black-bg" onclick="modalVanish();"></div>
    <div id="modal"></div>
    <div id="extra_info" style="margin-top: 20px;"></div>
</body>
</html>
